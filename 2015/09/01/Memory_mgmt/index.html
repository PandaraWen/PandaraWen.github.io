<!doctype html>
<html class="theme-next use-motion ">
<head>
	<!-- hexo-inject:begin --><!-- hexo-inject:end --><!--为了使用aevit的js，需要预先加载jquery_20150722-->
	<script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>
    

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>




<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.4"/>


    <meta name="description" content="一切皆为年少轻狂之诳语" />



  <meta name="keywords" content="iOS,Objective-C,内存管理," />





  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.4" />


<meta name="description" content="翻译自Apple官方文档，是时候表演翻译腔的技术了   介绍应用内存管理是：在程序运行时，分配内存，使用内存，然后在你使用完成之后释放它。一个编写良好的程序应该尽可能少地使用内存。在Objective-C中，内存管理同样可以被视为：一种在许许多多数据以及代码中，为有限的内存空间分配使用权。当你看完本guide，你就会知道该如何管理app的内存：显式管理对象的生命周期，并且在他们不再被需要的时候释">
<meta name="keywords" content="iOS,Objective-C,内存管理">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS内存管理—Manual retain-release">
<meta property="og:url" content="http://pandara.xyz/2015/09/01/Memory_mgmt/index.html">
<meta property="og:site_name" content="Pandara&#39;s Zone">
<meta property="og:description" content="翻译自Apple官方文档，是时候表演翻译腔的技术了   介绍应用内存管理是：在程序运行时，分配内存，使用内存，然后在你使用完成之后释放它。一个编写良好的程序应该尽可能少地使用内存。在Objective-C中，内存管理同样可以被视为：一种在许许多多数据以及代码中，为有限的内存空间分配使用权。当你看完本guide，你就会知道该如何管理app的内存：显式管理对象的生命周期，并且在他们不再被需要的时候释">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://7ls0ue.com1.z0.glb.clouddn.com/2015/08/30/the-imitation-game/memory_management_2x.png">
<meta property="og:image" content="http://7ls0ue.com1.z0.glb.clouddn.com/2015/09/01/Memory_mgmt/retaincycles_2x.png">
<meta property="og:updated_time" content="2015-10-10T08:44:05.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="iOS内存管理—Manual retain-release">
<meta name="twitter:description" content="翻译自Apple官方文档，是时候表演翻译腔的技术了   介绍应用内存管理是：在程序运行时，分配内存，使用内存，然后在你使用完成之后释放它。一个编写良好的程序应该尽可能少地使用内存。在Objective-C中，内存管理同样可以被视为：一种在许许多多数据以及代码中，为有限的内存空间分配使用权。当你看完本guide，你就会知道该如何管理app的内存：显式管理对象的生命周期，并且在他们不再被需要的时候释">
<meta name="twitter:image" content="http://7ls0ue.com1.z0.glb.clouddn.com/2015/08/30/the-imitation-game/memory_management_2x.png">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: '',
    sidebar: 'hide'
  };
</script>

    <title> iOS内存管理—Manual retain-release // Pandara's Zone </title>
    <link rel="shortcut icon" type="image/x-icon" href="https://images.pandara.xyz/pandara_zone/favico%202.ico" media="screen" /> 
    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>
<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">
<!-- hexo-inject:begin --><!-- hexo-inject:end --><!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->


  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?c5d0f36c537707dfe01cd190611c07b1";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>



<div class="container one-column page-post-detail">
    <div id="pandara-brand" class="my-brand">
      <div id="space-ship" class="pandara-image"></div>
      <div id="planet0" class="pandara-image"></div>
      <div id="earth" class="pandara-image"></div>
      <div id="planet1" class="pandara-image"></div>
      <div id="planet2" class="pandara-image"></div>
      <div id="planet3" class="pandara-image"></div>
      <div id="satellite" class="pandara-image"></div>
      <div id="planet4" class="pandara-image"></div>
      <div id="planet5" class="pandara-image"></div>
      <div id="planet6" class="pandara-image"></div>
    </div>
    <div class="headband"></div>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
        <div class="header-inner"><h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand" rel="start">
      <span class="logo">
        <i class="icon-logo"></i>
      </span>
      <span class="site-title">Pandara's Zone</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          
            <a href="/" rel="section">
              <i class="menu-item-icon icon-home"></i> <br />
              首页
            </a>
          
        </li>
      
        
        <li class="menu-item menu-item-categories">
          
            <a href="/categories" rel="section">
              <i class="menu-item-icon icon-categories"></i> <br />
              分类
            </a>
          
        </li>
      
        
        <li class="menu-item menu-item-about">
          
            <a href="/about.html" rel="section">
              <i class="menu-item-icon icon-about"></i> <br />
              我是谁˚∆˚
            </a>
          
        </li>
      
        
        <li class="menu-item menu-item-archives">
          
            <a href="/archives" rel="section">
              <i class="menu-item-icon icon-archives"></i> <br />
              归档
            </a>
          
        </li>
      
        
        <li class="menu-item menu-item-tags">
          
            <a href="/tags" rel="section">
              <i class="menu-item-icon icon-tags"></i> <br />
              标签
            </a>
          
        </li>
      
    </ul>
  

  
</nav>


        </div>
    </header>

    <main id="main" class="main">
        <div class="main-inner">
            <div id="content" class="content">
                

  <div id="posts" class="posts-expand">
    

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              iOS内存管理—Manual retain-release
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-09-01T00:00:00+08:00" content="2015-09-01">
            2015-09-01
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a href="/categories/你丫才码农/" itemprop="url" rel="index"><span itemprop="name">你丫才码农</span></a></span>

              
              

            
          </span>
        

        
          <span id="busuanzi_container_page_pv">
            &nbsp; | &nbsp;
            访客
            <span id="busuanzi_value_page_pv">0</span>
          </span>
        

       

      </div>
    </header>

    <div class="post-body">

      
      

      
        <span itemprop="articleBody"><blockquote>
<p>翻译自<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/MemoryMgmt.html" target="_blank" rel="noopener">Apple官方文档</a>，是时候表演翻译腔的技术了 </p>
</blockquote>
<h3 id="介绍">介绍</h3><p>应用内存管理是：在程序运行时，分配内存，使用内存，然后在你使用完成之后释放它。一个编写良好的程序应该尽可能少地使用内存。在Objective-C中，内存管理同样可以被视为：一种在许许多多数据以及代码中，为有限的内存空间分配使用权。当你看完本guide，你就会知道该如何管理app的内存：显式管理对象的生命周期，并且在他们不再被需要的时候释放他们。</p>
<p>虽然内存管理通常被认为是对单个对象而言的，但是你的目标实际上应该是管理对象图(object graph)。你需要确定在内存中的对象不会超过你实际需要的。</p>
<p><img src="http://7ls0ue.com1.z0.glb.clouddn.com/2015/08/30/the-imitation-game/memory_management_2x.png" alt="graph"></p>
<a id="more"></a>
<h4 id="概述">概述</h4><p>Objective-C提供两种途径来管理应用的内存。</p>
<ol>
<li>这是本文档阐述的方法，被称为“手动 retain-release”或者MRR，你需要自己追踪对象来显式管理内存。这已经以一种模式实现了，称为“引用计数”，它被Foundation类<code>NSObject</code>集成在运行时环境中。</li>
<li>另一种方法成为自动引用计数(Automatic Reference Counting, ARC)，系统使用跟MRR相同的引用计数体系。但是它是在编译时在适当的地方为你插入内存管理方法的调用。强烈推荐你在新工程中使用ARC。如果你使用ARC，那就没有必要明白这个文档中阐述的底层实现，虽然这在某些情况会很有帮助。想知道更多的关于ARC的内容，查看Transitioning to ARC Release Notes。</li>
</ol>
<h5 id="良好的练习能为你防止内存有关的问题">良好的练习能为你防止内存有关的问题</h5><p>有两种问题，会导致错误的内存管理：</p>
<ul>
<li>对仍在使用的数据进行释放或者重写<br>这会导致内存出错，并且通常会引起你的程序崩溃，更坏的是，可能会让用户数据出错。</li>
<li>没有释放不再使用的数据，引起内存泄露<br>内存泄露是指被分配出去的内存没有被释放，即使他永远都不会被再次使用。泄露会造成程序使用的内存不断增加，最终会造成系统性能低下或者你的程序被终止。</li>
</ul>
<p>然而从引用计数的角度考虑内存管理，通常是适得其反的。因为你会倾向于在实现细节层面考虑内存管理，而不是从你的实际目的的角度出发。相反，你应该从对象的拥有关系以及对象图(object graph)中考虑内存管理。</p>
<h5 id="使用分析工具来调试内存问题">使用分析工具来调试内存问题</h5><p>为了在编译时找出代码的问题，你可以使用Xcode内置的Clang Static Analyzer。<br>如果内存管理问题还是出现了，那么你可以使用另外一些手段来分析诊断问题：</p>
<ul>
<li>大多数工具以及计数都在文档<a href="https://developer.apple.com/library/ios/technotes/tn2239/_index.html#//apple_ref/doc/uid/DTS40010638" target="_blank" rel="noopener">Technical Note TN2239, iOS Debugging Magic</a>中阐述了，尤其是使用<code>NSZombie</code>来帮助找出被重复释放的对象。</li>
<li>你可以使用Instrument来跟踪引用计数时间，还有寻找内存泄露。查看你app的<a href="https://developer.apple.com/library/ios/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/GatheringDatafortheFirstTime/GatheringDatafortheFirstTime.html#//apple_ref/doc/uid/TP40004652-CH5" target="_blank" rel="noopener">Collecting Data</a>。</li>
</ul>
<h3 id="内存管理策略">内存管理策略</h3><p>在引用计数环境下使用内存管理，可以通过在<code>NSObject</code>协议中定义的一组发方法，还有“命名惯例”。<code>NSObject</code>类也定义了一个方法，<code>dealloc</code>，当对象被释放的时候自动被调用。这篇文章阐述了所有你在cocoa程序的内存管理中需要知道的基本法则，并且提供了一些关于正确使用的例子。</p>
<h4 id="基本内存管理规则">基本内存管理规则</h4><p>内存管理模式是基于对象拥有关系的。一个对象可能会有一个或者多个owner。只要一个对象至少拥有一个owner，它就会继续存在。如果一个对象一个owner都没有，那么运行时系统就会自动销毁它。为了确定什么时候你拥有你的对象，而什么时候你没有，cocoa设立了如下的策略：</p>
<ul>
<li><strong>你拥有你所创建的任何对象</strong><br>你可以通过名字以”alloc”、”new”、”copy”、或者”mutableCopy”开头的这些方法来创建对象（例如，alloc，newObject，mutableCopy）。</li>
<li><strong>你可以使用retain来拥有一个对象的所有权</strong><br>接收到此调用的对象通常保证在他接收到retain所在的方法中保持有效，并且retain方法会安全地将这个对象返回给调用者。你通常会在这两种情况中使用<code>retain</code>：(1)在accessor方法或者<code>init</code>方法的实现中，取得你想要作为属性值(property value)储存起来的对象的所有权；(2)防止一个对象由于某些操作的副作用而变得不可用。</li>
<li><strong>当你不在需要它，你需要释放你所拥有的对象的所有权</strong><br>你可以通过方法<code>release</code>和<code>autorelease</code>来释放一个对象的所有权。在coco的专有术语中，释放一个对象的所有权通常被称为”releasing”一个对象。</li>
<li><strong>你不能释放一个你并不拥有的对象的所有权</strong><br>这是前面的这些政策的必然结果，只是明显地提出来而已。</li>
</ul>
<h5 id="一个简单的例子">一个简单的例子</h5><p>为了将上述的策略描述清楚，考虑下面的代码片段<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	Person *aPerson = [[Person alloc] init];</span><br><span class="line">	// ...</span><br><span class="line">	NSString *name = aPerson.fullName;</span><br><span class="line">	// ...</span><br><span class="line">	[aPerson release];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>person对象通过<code>alloc</code>方法来被创建，所以它随后在不再需要它的时候向他发送<code>release</code>消息。person的name(Nsstring *name)并没有通过owning method来被取得所有权，所以它没有被发送<code>release</code>消息。注意，这个例子中使用<code>release</code>而不是<code>autorelease</code>。</p>
<h5 id="使用autorelease来发送延迟的release">使用autorelease来发送延迟的release</h5><p>当你需要发送一个延迟的<code>release</code>消息，你可以使用<code>autorelease</code>——典型的例子是，当你在一个方法中返回一个对象时。例如，你可以实现一个<code>fullName</code>方法，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (NSString *)fullName &#123;</span><br><span class="line">	NSString *string = [[[NSString alloc] initWithFormat:@&quot;%@ %@&quot;, self.firstName, self.lastName] autorelease];</span><br><span class="line">	return string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>你拥有从<code>alloc</code>中被返回的string。要服从内存管理策略，你就需要在你失去string的引用之前放弃他的所有权。然而如果你使用<code>release</code>，那么string就会在它被返回之前被回收（这个方法就会返回一个不可用的对象）。使用<code>autorelease</code>的话，你就表示你想要放弃所有权，但是你允许方法的调用者在string被回收之前使用它。</p>
<p>你同样可以这样来实现<code>fullName</code>方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (NSString *)fullName &#123;</span><br><span class="line">	NSString *string = [NSString stringQWithFormat:@&quot;%@ %@&quot;, self.firstName, self.lastName];</span><br><span class="line">	return string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从基本规则来看，你并没有拥有<code>stringWithFormat</code>方法所返回的string的所有权，所以你可以安全地从方法中返回string。</p>
<p>相反地，下面这个实现是错误的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (NSString *)fullName &#123;</span><br><span class="line">	NSString *string = [[NSString alloc] initWithFormat:@&quot;%@ %@&quot;, self.firstName, self.lastName];</span><br><span class="line">	return string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>根据命名惯例，没有任何东西可以表明<code>fullName</code>的调用者拥有返回的string的所有权。调用者因此没有任何理由来释放返回的string，而它也因此而被泄露了。</p>
<h5 id="你并不拥有通过引用返回的对象">你并不拥有通过引用返回的对象</h5><p>一些在cocoa中的方法阐述了某个对象是通过引用返回的(也就是说，他们接受一个<code>ClassName **</code>或者<code>id *</code>类型的对象)。比较通用的模式是，使用包含错误信息的<code>NSError</code>对象，例如<code>initWithContentsOfURL:options:error: (NSData) and initWithContentsOfFile:encoding:error: (NSString)</code>。</p>
<p>在这里情况里面也应用了相同的规则。当你调用了这些方法，你并没有创建<code>NSError</code>对象，所以你并没有拥有它。因而你没有必要去释放他。例子如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">NSString *fileName = &lt;#Get a file name#&gt;;</span><br><span class="line">NSError *error;</span><br><span class="line">NSString *string = [[NSString alloc] initWithContentsOfFile:fileName encoding:NSUTF8StringEncoding error:&amp;error];</span><br><span class="line">if (string == nil) &#123;</span><br><span class="line">	// Deal with error...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ...</span><br><span class="line">[string release];</span><br></pre></td></tr></table></figure></p>
<h4 id="实现dealloc方法来释放对象的所有权">实现dealloc方法来释放对象的所有权</h4><p><code>NSObject</code>对象定义了一个方法，<code>dealloc</code>，当一个对象一个拥有者都没有的话，他就会被自动调用，并且它的内存就会被回收——cocoa术语中它被称为”free”或者”deallocate”。<code>dealloc</code>方法的角色是释放对象自己的内存，并且销毁他所拥有的资源，包括所有对象变量的拥有权。</p>
<p>下面的例子阐述了如何为<code>Person</code>类实现<code>dealloc</code>方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@interface Person : NSObject</span><br><span class="line">@property (retain) NSString *firstName;</span><br><span class="line">@property (retain) NSString *lastName;</span><br><span class="line">@property (assign, readonly) NSString *fullName;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementations Person</span><br><span class="line">// ...</span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">	[_firstName release];</span><br><span class="line">	[_lastName release];</span><br><span class="line">	[super dealloc];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>重要：永远不要直接调用任何对象的<code>dealloc</code>方法。<br>你需要在你的实现的<strong>末尾</strong>中调用父类的实现。<br>你不应该将系统资源的管理与对象生命周期混在一起<br>当程序终止时，对象可能不会被发送<code>dealloc</code>消息。因为进程的内存在进程退出的时候自动清空，很显然，让操作系统来清空所有资源比逐个逐个调用内存管理方法高效的多。</p>
</blockquote>
<h4 id="Core_Foundation_使用相似但是不相同的规则">Core Foundation 使用相似但是不相同的规则</h4><p>对于Core Foundation对象来说，它们会使用相似的内存管理策略（可查看Memory Management Programming Guide for Core Foundation）。然而对于cocoa与Core Foundation来说，命名惯例是不一样的。特别地，创建Core Foundation的规则并不适用于返回OC对象的方法。例如，在下面的代码片段，你<strong>不需要</strong>释放myInstance的所有权：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyClass *myInstance = [MyClass createInstance];// ???不明所以然</span><br></pre></td></tr></table></figure></p>
<h3 id="内存管理实战">内存管理实战</h3><p>虽然上面介绍的基本盖面都很直接明了，但你可以通过一些步骤来让内存的管理更加简单，并且帮助你确保你的程序在减少它所需要的资源时仍然可靠健壮。</p>
<h4 id="使用Accessor方法来让内存管理更加简单">使用Accessor方法来让内存管理更加简单</h4><p>如果你的类拥有一个对象属性，你需要确保所有被设置为属性的对象当你在使用的时候不会被释放掉。因此，当它被设置为属性的时候，你必须要获取这个对象的所有权。你必须同样要确保稍候要释放所有现在正持有的对象的所有权。</p>
<p>可能某种意义上来说这样做很单调枯燥乏味，但是如果你使用使用accessor方法，那么出现内存管理问题的风险就会大大降低。如果你对你的成员变量在普通代码中使用<code>retain</code>和<code>release</code>，那么你机会注定会出现错误。</p>
<p>举个例子，有一个Counter对象，而你现在要设置它的count<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@interface Count: NSObject</span><br><span class="line">@property (nonatomic, retain) NSNumber *count;</span><br><span class="line">@end;</span><br></pre></td></tr></table></figure></p>
<p>这个属性生命了两个<code>accessor</code>方法。特别地，你应该要求编译器来生成那些方法。然而，看看它们是怎么被实现的也是有好处的。</p>
<p>在“get”方法中，你只是返回一个synthesized的实例变量。所以并不需要<code>retain</code>或者<code>release</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (NSNumber *)count &#123;</span><br><span class="line">	return _count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在“set”方法，如果你需要向你的新的object发送<code>retain</code>消息，来获取他的所有权，因而能确保你的对象不会被释放掉。同时你也需要放弃旧的count对象的所有权——向他发送<code>release</code>消息（Objective-C中允许向<code>nil</code>对象发送消息，因而即使_count还没有被设置，下面的实现也依然可以执行）。你需要在<code>[newCount retain]</code>之后调用<code>release</code>，以防newCount与oldCount是同一个对象。否则在<code>[newCount retain]</code>之前，他就被释放掉了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (void)setCount:(NSNumber *)newCount &#123;</span><br><span class="line">	[newCount retain];</span><br><span class="line">	[_count release];</span><br><span class="line"></span><br><span class="line">	_count = newCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="使用Accessor方法来设置属性值">使用Accessor方法来设置属性值</h5><p>假设你想要实现一个方法来重置计数器。你有两个选择，第一个选择是通过<code>alloc</code>来创建<code>NSNumber</code>对象，因此你需要用<code>release</code>来对应。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)reset &#123;</span><br><span class="line">	NSNumber *zero = [[NSNumber alloc] initWithInteger:0];</span><br><span class="line">	[self setCount:zero];</span><br><span class="line">	[zero release];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第二种方法使用一个方便的构造器来创建新的<code>NSNumber</code>对象。因此没有必要发送<code>retain</code>或者<code>release</code>对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)reset &#123;</span><br><span class="line">	NSNumber *zero = [NSNumber numberWithInteger:0];</span><br><span class="line">	[self setCount:zero];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意这两种方法都是用set accesstor方法。</p>
<p>下面这种方法会几乎毫无疑问地对所有简单的情况可用，但是由于他没有使用accessor方法，所以这样做的话会几乎百分百在某些状况引起错误(例如，当你忘记了retain或者release，或者如果内存管理语法更改了)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)reset &#123;</span><br><span class="line">	NSNumber *zero = [[NSNumber alloc] initWithInteger:0];</span><br><span class="line">	[_count release];</span><br><span class="line">	_count = zero;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>同样需要注意，如果你正在使用kvo，以这种方法来改变变量不符合kvo规则。</p>
<h5 id="不要在initializer方法和dealloc方法中使用accessor方法">不要在initializer方法和dealloc方法中使用accessor方法</h5><p>唯一你不应该使用accessor方法来设置实例变量的地方是initializer方法以及<code>dealloc</code>。要用一个表示0的number对象来初始化一个counter对象，你可能要像下面这样实现<code>init</code>方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (id)init &#123;</span><br><span class="line">	self = [super init];</span><br><span class="line">	if (self) &#123;</span><br><span class="line">		_count = [[NSNumber alloc] initWithInteger:0];</span><br><span class="line">	&#125;</span><br><span class="line">	return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果要用一个counter对象来初始化另外一个counter对象，而不是0，你需要实现一个<code>initWithCount</code>函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (id)initWithCount:(NSNumber *)startingCount &#123;</span><br><span class="line">	self = [super init];</span><br><span class="line">	if (self) &#123;</span><br><span class="line">		_count = [startingCount copy];</span><br><span class="line">	&#125;</span><br><span class="line">	return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于Counter类有一个对象实例变量，你必须实现<code>dealloc</code>方法。他应该释放所有实例变量的所有权，通过给他们发送<code>release</code>消息，并且在最后他应该调用父级的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)dealloc &#123;</span><br><span class="line">	[_count release];</span><br><span class="line">	[super dealloc];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="使用弱引用来避免retain_cycle">使用弱引用来避免retain cycle</h4><p>retain一个对象会创建一个该对象的强引用(strong reference)。一个对象直到所有指向他的强引用都被释放掉之后才会被释放。有一个被称为retain cycle的问题，会由两个互相引用的对象引起：就是说，他们互相都拥有对方的强引用（更直接点，可以说有一连串对象，上一个拥有下一个对象的强引用，并且最后一个对象拥有第一个对象的强引用）。</p>
<p>下图中展示的对象关系阐述了一种可能会发生的retain cycle。document对象拥有一个page对象，代表文档中的每一页。每一个page对象拥有一个属性来追踪他是在哪一个文档中的。如果document对象对page拥有一个强引用，并且page对象同样也对document对象拥有一个强引用，那么他们任一个都不会被释放。document的引用在page对象被释放之前不会被置零，并且在document对象被释放之前page对象不会被释放。</p>
<p><center><img src="http://7ls0ue.com1.z0.glb.clouddn.com/2015/09/01/Memory_mgmt/retaincycles_2x.png" alt="feature"></center><br>解决retain cycle的办法是使用弱引用(weak reference)。一个弱引用是一种“不拥有”的关系。对象a拥有对象b的弱关系，但实际上a并没有retain b。</p>
<p>然而要保证object graph是完整的，那么就应该在某处有一些强引用（如果只有弱引用，page以及paragraph会因为没有任何owner而被释放掉）。cocoa因而建立了一种惯例，“父对象”应该持有对他的“孩子”的强引用，并且孩子应该持有其父亲的弱引用。</p>
<p>因此，上述的例子中，document对象拥有一个强引用来指向他的page对象，而page对象拥有指向document对象的弱引用。</p>
<p>cocoa中的弱引用包含但不仅限于：table data sources，outline view items，notification observers，还有miscellaneous targets和delegates。</p>
<p>在你需要向持有弱引用的对象发送消息的时候，需要留神。如果你向一个被释放掉的对象发送消息，你的程序会崩溃。你需要非常清楚你的对象什么时候有效什么时候变得不可用。在大多数情况，被弱引用指向的对象在被回收前有责任通知其他对象。例如，当年你在notification center注册了一个对象，notification center保存那个对象的弱引用，并且当合适的通知被发送时，通知中心会向该对象发送消息。当对象被回收时，你需要将它从notification center中取消注册，好让消息中心不再向该对象发送消息。同样地，当delegate对象被回收，你需要将delegate移除，通过<code>setDelegate</code>函数将他设置为nil。这些调用通常都会被放在<code>dealloc</code>函数中。</p>
<h4 id="避免引起对你正在使用的对象的deallocation">避免引起对你正在使用的对象的deallocation</h4><p>cocoa的所有权政策指定了，接受消息的对象需要在整个函数作用域之内可用。同样也应该保证，能够在当前被调用的方法中返回这个接收消息的对象，而不用担心它被释放掉。对你的程序来说，一个对象的getter方法返回一个对象还是一个算数值并不重要，重要的是那个返回的对象在你需要的时候仍然可用。</p>
<p>下面是一些在这个规则之下，偶尔会出现的exception，主要是两类之一：</p>
<p><strong>1. 当一个对象从基本容器类中被移走</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">heisenObject = [array objectAtIndex: n];</span><br><span class="line">[array removeObjectAtIndex: n];</span><br><span class="line">//heisen 对象现在可能会不可用</span><br></pre></td></tr></table></figure></p>
<p>当一个对象从基础容器类中被移除时，它会被发送<code>release</code>消息，而不是<code>autorelease</code>消息。如果那个容器是被移除对象的唯一拥有者，那么被移除的对象(例如<code>heisenObject</code>)就会被马上dealloc。</p>
<p><strong>2. 当“父对象”被释放</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">id parent = &lt;#create a parent object#&gt;;</span><br><span class="line">//...</span><br><span class="line"> heisenObject = [parent child];</span><br><span class="line"> [parent release];//或者，例如: self.parent = nil;</span><br><span class="line"> //heisenObject 现在可能会不可用</span><br></pre></td></tr></table></figure></p>
<p>在某些情况中，你从其他对象接受了一个对象A，然后直接或者间接release了父对象。如果release父对象会造成它被dealloc，并且那个父对象是对象A的唯一拥有者，那么对象A(就像<code>heisenObject</code>)就会同时被deallocate(假设它在父对象的<code>dealloc</code>方法中被发送<code>release</code>消息而不是<code>autorelease</code>消息)。</p>
<p>为了避免这些情况，你需要在接受到<code>heisenObject</code>的时候retain，并且当你使用完的时候释放它。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">heisenObject = [[array objectAtIndex: n] retain];</span><br><span class="line">[array removeObjectAtIndex: n];</span><br><span class="line">//Use heisenObject...</span><br><span class="line">[heisenObject release];</span><br></pre></td></tr></table></figure></p>
<h4 id="不要使用dealloc来管理稀缺资源">不要使用dealloc来管理稀缺资源</h4><p>你不应该在<code>dealloc</code>方法中管理稀缺资源，例如file descriptor, network connection, and buffer or caches。特别地，你不应该试图设计出一个能主动调用<code>dealloc</code>函数的类。<code>dealloc</code>的调用可能会由于bug或者程序挂掉而延时或者被跳过。</p>
<p>相反，如果你有一个管理稀缺资源的类，你应该这样来设计你的程序：当你不再需要使用某个稀缺资源的时候，可以告诉管理资源的类对象，来让它执行“clean up”操作。然会你会对那个对象发送release消息，接着它会被dealloc，但是就算它没有被dealloc，你也不会遭受额外问题。</p>
<p>但是如果你试图将资源管理放在dealloc中，就会出问题。例如：<br><strong>1. 对象图释放时的顺序依赖</strong><br>对象图释放机制是无序的。即使你可能会预想——或者得到——一个特定的准许，但是你同时也会引入脆弱性。如果一个对象意外地被autorelease而不是release，那么释放的顺序就会改变，而这可能会导致意外结果。</p>
<p><strong>2. 稀缺资源的不回收</strong><br>内存泄露是应该被修复的bug，但是他们通常不会立即致命。如果稀缺资源在你希望他们被release的时候没有被释放，那么你会引起更加严重的问题。例如如果你的程序将descriptors耗尽，那么用户可能无法保存数据。</p>
<p><strong>3. 清理逻辑在错误的线程里面被执行</strong><br>如果一个对象在意外的时间点被autorelease，而且它恰好进入了某个线程的autorelease pool，那么它就会被dealloc。对那些需要在其他线程里面被访问的资源来说，这是很致命的。</p>
<h4 id="容器拥有它们包含的对象">容器拥有它们包含的对象</h4><p>当你将一个对象添加到容器中(例如一个array， dictionary或者set)，这些容器就会拥有它的所有权。当这个对象从容器中被移除，或者容器本身被释放掉，容器会释放对其内对象的所有权。因此，几个例子，如果你想要创建numbers的数组，你可以选择一下任一种方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray *array = &lt;#Get a mutable array#&gt;;</span><br><span class="line">NSUinteger i;</span><br><span class="line">//...</span><br><span class="line">for (i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">	NSNumber *convenienceNumber = [NSNumber numberWithInteger:i];</span><br><span class="line">	[array addObject: convenienceNumber];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这个例子中，你没有调用<code>alloc</code>，所以你也不需要调用<code>release</code>。而且也没有必要retain新生成的number，因为array会去做。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray *array = &lt;#Get a mutable array#&gt;;</span><br><span class="line">NSUInteger i;</span><br><span class="line">//...</span><br><span class="line">for (i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">	NSNumber *allocedNumber = [[NSNumber alloc] initWithInteger: i];</span><br><span class="line">	[array addObject:allocedNumber];</span><br><span class="line">	[allocedNumber release];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，你需要向number发送release消息，因为你调用了alloc。由于数组会retain添加到其中的number，所以只要它还在数组中，它就不会被释放。</p>
<p>想要明白这，你想象正在实现一个容器类。你需要确定你接受的对象不会在你眼皮底下消失，所以你需要在它们被传进来的时候向它们发送<code>retain</code>消息。如果他们被移走，你需要发送<code>release</code>来平衡。并且你需要在自己的<code>dealloc</code>方法中向所有剩下的对象发送<code>release</code>。</p>
<h4 id="“拥有关系”策略使用引用retain_count来实现的">“拥有关系”策略使用引用retain count来实现的</h4><p>ownership策略通过引用计数来实现——通常被称为“retain count”。每一个对象都有retain count。</p>
<ul>
<li>当你创建一个对象，它有一个值为1的retain count</li>
<li>当你向一个对象发送<code>retain</code>消息，它的retain count会加1</li>
<li>当你向一个对象发送<code>release</code>消息，它的retain count会减1；当你向一个对象发送<code>autorelease</code>消息，它的retain count会在当前的autorelease pool块的末尾减1</li>
<li>如果一个对象的retain count减为0，它会被释放。</li>
</ul>
<blockquote>
<p>重要：你不应该显示查询某个对象的retain count是多少(详见<code>retainCount</code>)。因为得到的结果总是不准确的，你可能不知道除了你以外有多少framework对象会retain你的对象。在调试内存问题的时候，你应该关心的是：确保你的代码遵守了ownership规则。</p>
</blockquote>
<h3 id="使用Autorelease_Pool_Blocks">使用Autorelease Pool Blocks</h3><p>Autorelease pool block提供了一种机制，让你可以释放对对象的所有权，但是避免了对象被马上释放的可能性(例如当你在某个方法中返回对象）。特别地，虽然你不需要创建自己的Autorelease pool block，但是有一些情况你还是最好这样做。</p>
<h4 id="关于Autorelease_Pool_Block">关于Autorelease Pool Block</h4><p>一个autorelease pool block使用<code>@autoreleasepool</code>来标识，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@autoreleasepool &#123;</span><br><span class="line">	// 创建autorelease 对象</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在autorelease pool block的末尾，在pool内被发送<code>autorelease</code>消息的对象会被发送<code>release</code>消息。</p>
<p>就像其他代码块，autorelease pool block也可以被嵌套：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@autorealsepool &#123;</span><br><span class="line">	//...</span><br><span class="line">	@autoreleasepool &#123;</span><br><span class="line">		//...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实际上你一般不会看到像上面那样的代码，典型的情况是，在某个文件中autorelease pool block里的代码会调用在另外一个文件中被包含在其他autorelease pool block中的代码。对于一个给定的<code>autorelease</code>消息，相应的<code>release</code>消息会在<code>autorelase</code>被发送所在的autorelease pool block 末尾被发送。</p>
<p>cocoa 通常都会期望代码在autorelease pool block中被执行，否则autorelease对象不会被释放而你的程序因此而泄露内存。（如果你在autorelease pool block之外向对象发送<code>autorelease</code>消息，cocoa会log一个恰当的错误信息）。AppKit跟UIKit框架都会在autorelease pool block中来进行某些时间循环迭代（例如鼠标点击或者点击）。因此通常不需要自己创建autorelease pool block，甚至很少看到创建的代码。然而，有三种情况，你可能需要使用自己的autorelease pool block：</p>
<ul>
<li>如果你正在编写不是基于UI framework的程序，例如command-line tool。</li>
<li>如果你编写一个会创建很多临时对象的循环。<br>你可能会在循环中使用一个autorelease pool block来在下一次迭代之前销毁那些对象。在循环中使用一个autorelease pool block能够帮助降低程序占用的最大内存。</li>
<li>如果你生成一个子线程<br>你需要在线程开始被执行的时候创建自己的autorelease pool block，否则，你的程序会泄露对象。</li>
</ul>
<h4 id="使用Autorelease_Pool_Block来降低内存峰值">使用Autorelease Pool Block来降低内存峰值</h4><p>很多程序会创建autoreleased临时对象。这些对象在到达pool末尾之前，都会增加程序的内存占用值。很多情况中，允许临时对象累积在当前循环中累积不会引起过分的开销；然而在另外一些情况中，你可能会创建大量的临时对象，并且让内存的占用飙升不少，因而你需要尽快将他们释放。在这些少数情况里面，你可以创建自己的autorelease pool block。在block的末尾，那些临时对象会被释放掉，因而它们能够被释放，而降低程序的内存占用。</p>
<p>下面的例子示范了如何为循环使用局部autorelease pool block:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NSArray *urls = &lt;# an array of file urls #&gt;;</span><br><span class="line">for (NSURL *url in urls) &#123;</span><br><span class="line">	@autoreleasepool &#123;</span><br><span class="line">		NSError *error;</span><br><span class="line">		NSString *fileContents = [NSString stringwithContentsOfURL:url encoding: NSUTF8StringEncoding error:&amp;error];</span><br><span class="line">		/*对字符串进行处理，创建并且自动释放更多对象。*/</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>佛如循环一次处理一个文件。任何在autorelease pool block中被发送<code>autorelease</code>消息的对象都会在pool结束的时候被释放。</p>
<p>在autorelease pool block后面，你应该将所有在autorelease pool block中被发送autorelease消息对象当作已经被销毁。不要试图再向它们发送消息或者在你的方法中向调用者返回它们。如果你必须在一个autorelease pool block之外使用一个临时的对象，就下下面例子中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (id)findMatchingObject:(id)anObject &#123;</span><br><span class="line">	id match;</span><br><span class="line">	while (match == nil) &#123;</span><br><span class="line">		@autoreleasepool &#123;</span><br><span class="line">			/*执行一个会产生大量临时对象的查找操作*/</span><br><span class="line">			match = [self expensiveSearchForObject: anObject];</span><br><span class="line"></span><br><span class="line">			if (match != nil) &#123;</span><br><span class="line">				[match retain];/* 保存match的所有权 */</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return [match autorelease]; /*返回它*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在autorelease pool block中向<code>match</code>发送<code>retain</code>，能够将它的生命周期延展到pool之外，让它能够在循环之外接受消息并且能够被返回到<code>findMatchingObject</code>的调用者中。</p>
<h4 id="Autorelease_Pool_Block_与线程">Autorelease Pool Block 与线程</h4><p>在cocoa 程序中，每个线程都会维持它自己的autorelease pool block栈。如果你正在编写一个foundation-only的程序，或者如果你生成自己的子线程，那么你就需要创建自己的autorelease pool block。</p>
<p>如果你的程序或者线程是长时间存在的或者可能生成大量的autoreleased对象，你应该使用autorelease pool blocks（就像AppKit和UIKit在主线程做的那样）。否则，autoreleased对象会累积然后你程序使用的内存会一直增长。如果你生成的子线程不会make coca call，你不需要使用autorelease pool block。</p>
<blockquote>
<p>注意：如果你使用POSIX线程API创建子线程而不是使用NSThread，那么你不能使用cocoa除非cocoa是处于多线程模式。cocoa只有在穿件了它的第一个NSThread对象之后才能进入多线程模式。想要在二级POSIX线程中使用cocoa，你的程序必须要首先生成最少一个NSThread对象，which can immediately exit。你可以使用<code>NSThread</code>的类方法<code>isMultiThreaded</code>来测试cocoa是否处于多线程模式。</p>
</blockquote>
<p>（完，未校对）</p>
<p><br><br>以上</p>
</span>
      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/iOS/" rel="tag">#iOS</a>
          
            <a href="/tags/Objective-C/" rel="tag">#Objective-C</a>
          
            <a href="/tags/内存管理/" rel="tag">#内存管理</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-prev post-nav-item">
            
              <a href="/2015/09/03/birdman/" rel="prev">你个鸟人</a>
            
          </div>

          <div class="post-nav-next post-nav-item">
            
              <a href="/2015/08/31/20150828_gcd_dispatch_queue/" rel="next">iOS并发编程—Dispatch Queues</a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


            </div>

            

            
              <div class="comments" id="comments">
                
                  <div id="disqus_thread">
                    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                  </div>
                
              </div>
            
        </div>

        
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <div class="site-author-avatar"></div>
          <p class="site-author-name" itemprop="name">Pandara</p>
        </div>
        <p class="site-description motion-element" itemprop="description">一切皆为年少轻狂之诳语</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">91</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="/categories">
              <span class="site-state-item-count">9</span>
              <span class="site-state-item-name">分类</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">43</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/PandaraWen" target="_blank">Github</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://dribbble.com/PandaraWen" target="_blank">Dribbble</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/WenPandara" target="_blank">Twitter</a>
              </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
            <p class="site-author-name">基情链接</p>
            
              <span class="links-of-author-item">
              <a href="http://aevit.xyz/" target="_blank">Aevit's Lab</a>
              </span>
            
              <span class="links-of-author-item">
              <a href="http://w3ctrain.com" target="_blank">W3cTrain</a>
              </span>
            
              <span class="links-of-author-item">
              <a href="http://mrazy.com" target="_blank">梦灯笼</a>
              </span>
            
          
        </div>

      </section>

      
        <section class="post-toc-wrap sidebar-panel-active">
          <div class="post-toc-indicator-top post-toc-indicator"></div>
          <div class="post-toc">
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#介绍"><span class="nav-number">1.</span> <span class="nav-text">介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#概述"><span class="nav-number">1.1.</span> <span class="nav-text">概述</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#良好的练习能为你防止内存有关的问题"><span class="nav-number">1.1.1.</span> <span class="nav-text">良好的练习能为你防止内存有关的问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#使用分析工具来调试内存问题"><span class="nav-number">1.1.2.</span> <span class="nav-text">使用分析工具来调试内存问题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存管理策略"><span class="nav-number">2.</span> <span class="nav-text">内存管理策略</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基本内存管理规则"><span class="nav-number">2.1.</span> <span class="nav-text">基本内存管理规则</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#一个简单的例子"><span class="nav-number">2.1.1.</span> <span class="nav-text">一个简单的例子</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#使用autorelease来发送延迟的release"><span class="nav-number">2.1.2.</span> <span class="nav-text">使用autorelease来发送延迟的release</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#你并不拥有通过引用返回的对象"><span class="nav-number">2.1.3.</span> <span class="nav-text">你并不拥有通过引用返回的对象</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实现dealloc方法来释放对象的所有权"><span class="nav-number">2.2.</span> <span class="nav-text">实现dealloc方法来释放对象的所有权</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Core_Foundation_使用相似但是不相同的规则"><span class="nav-number">2.3.</span> <span class="nav-text">Core Foundation 使用相似但是不相同的规则</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存管理实战"><span class="nav-number">3.</span> <span class="nav-text">内存管理实战</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#使用Accessor方法来让内存管理更加简单"><span class="nav-number">3.1.</span> <span class="nav-text">使用Accessor方法来让内存管理更加简单</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#使用Accessor方法来设置属性值"><span class="nav-number">3.1.1.</span> <span class="nav-text">使用Accessor方法来设置属性值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#不要在initializer方法和dealloc方法中使用accessor方法"><span class="nav-number">3.1.2.</span> <span class="nav-text">不要在initializer方法和dealloc方法中使用accessor方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用弱引用来避免retain_cycle"><span class="nav-number">3.2.</span> <span class="nav-text">使用弱引用来避免retain cycle</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#避免引起对你正在使用的对象的deallocation"><span class="nav-number">3.3.</span> <span class="nav-text">避免引起对你正在使用的对象的deallocation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#不要使用dealloc来管理稀缺资源"><span class="nav-number">3.4.</span> <span class="nav-text">不要使用dealloc来管理稀缺资源</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#容器拥有它们包含的对象"><span class="nav-number">3.5.</span> <span class="nav-text">容器拥有它们包含的对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#“拥有关系”策略使用引用retain_count来实现的"><span class="nav-number">3.6.</span> <span class="nav-text">“拥有关系”策略使用引用retain count来实现的</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用Autorelease_Pool_Blocks"><span class="nav-number">4.</span> <span class="nav-text">使用Autorelease Pool Blocks</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#关于Autorelease_Pool_Block"><span class="nav-number">4.1.</span> <span class="nav-text">关于Autorelease Pool Block</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用Autorelease_Pool_Block来降低内存峰值"><span class="nav-number">4.2.</span> <span class="nav-text">使用Autorelease Pool Block来降低内存峰值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Autorelease_Pool_Block_与线程"><span class="nav-number">4.3.</span> <span class="nav-text">Autorelease Pool Block 与线程</span></a></li></ol></li></ol></div>
            
          </div>
          <div class="post-toc-indicator-bottom post-toc-indicator"></div>
        </section>
      

      <div class="side-bar-foot-decorate">
        <div class="side-bar-man motion-element"></div>
        <div class="side-bar-star motion-element"></div>
      </div>
    </div>
  </aside>


    </main>

    <footer id="footer" class="footer">
        <div class="footer-inner">
            <div class="copyright" >
  
  &copy; &nbsp; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="icon-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Pandara</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="powered-by">
  粤ICP备17156711号-1
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT
  </a>
</div>



        </div>
    </footer>

    <div class="back-to-top"></div>
</div>

  
  
  
    
    

  

    <script type="text/javascript">
      var disqus_shortname = 'pandara';
      var disqus_identifier = '2015/09/01/Memory_mgmt/';
      var disqus_title = 'iOS内存管理—Manual retain-release';
      var disqus_url = 'http://pandara.xyz/2015/09/01/Memory_mgmt/';

      function run_disqus_script(disqus_script){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');
      
        run_disqus_script('embed.js');
      
    </script>
  


  
  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.4"></script>
  <script type="text/javascript" src="/js/fancybox-aevit.js"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.4"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.4" id="motion.global"></script>



  <script type="text/javascript" src="/js/search-toggle.js"></script>


  
<script type="text/javascript" src="/js/bootstrap.scrollspy.js?v=0.4.4" id="bootstrap.scrollspy.custom"></script>


<script type="text/javascript" id="sidebar.toc.highlight">
  $(document).ready(function () {
    var tocSelector = '.post-toc';
    var $tocSelector = $(tocSelector);
    var activeCurrentSelector = '.active-current';

    $tocSelector
      .on('activate.bs.scrollspy', function () {
        var $currentActiveElement = $(tocSelector + ' .active').last();

        removeCurrentActiveClass();
        $currentActiveElement.addClass('active-current');

        $tocSelector[0].scrollTop = $currentActiveElement.position().top;
      })
      .on('clear.bs.scrollspy', function () {
        removeCurrentActiveClass();
      });

    function removeCurrentActiveClass () {
      $(tocSelector + ' ' + activeCurrentSelector)
        .removeClass(activeCurrentSelector.substring(1));
    }

    function processTOC () {
      getTOCMaxHeight();
      toggleTOCOverflowIndicators();
    }

    function getTOCMaxHeight () {
      var height = $('.sidebar').height() -
                   $tocSelector.position().top -
                   $('.post-toc-indicator-bottom').height();

      $tocSelector.css('height', height);

      return height;
    }

    function toggleTOCOverflowIndicators () {
      tocOverflowIndicator(
        '.post-toc-indicator-top',
        $tocSelector.scrollTop() > 0 ? 'show' : 'hide'
      );

      tocOverflowIndicator(
        '.post-toc-indicator-bottom',
        $tocSelector.scrollTop() >= $tocSelector.find('ol').height() - $tocSelector.height() ? 'hide' : 'show'
      )
    }

    $(document).on('sidebar.motion.complete', function () {
      processTOC();
    });

    $('body').scrollspy({ target: tocSelector });
    $(window).on('resize', function () {
      if ( $('.sidebar').hasClass('sidebar-active') ) {
        processTOC();
      }
    });

    onScroll($tocSelector);

    function onScroll (element) {
      element.on('mousewheel DOMMouseScroll', function (event) {
          var oe = event.originalEvent;
          var delta = oe.wheelDelta || -oe.detail;
          var self = this;

          this.scrollTop += ( delta < 0 ? 1 : -1 ) * 30;
          event.preventDefault();

          toggleTOCOverflowIndicators();
      });
    }

    function tocOverflowIndicator (indicator, action) {
      $(indicator).velocity('stop').velocity({
        opacity: action === 'show' ? 0.4 : 0
      }, { duration: 100 });
    }

  });
</script>


  <script type="text/javascript" id="sidebar.nav">
    $(document).ready(function () {
      var html = $('html');

      $('.sidebar-nav li').on('click', function () {
        var item = $(this);
        var activeTabClassName = 'sidebar-nav-active';
        var activePanelClassName = 'sidebar-panel-active';
        if (item.hasClass(activeTabClassName)) {
          return;
        }

        var currentTarget = $('.' + activePanelClassName);
        var target = $('.' + item.data('target'));

        currentTarget.velocity('transition.slideUpOut', 200, function () {
          target
            .velocity('stop')
            .velocity('transition.slideDownIn', 200)
            .addClass(activePanelClassName);
        });

        item.siblings().removeClass(activeTabClassName);
        item.addClass(activeTabClassName);
      });

      $('.post-toc a').on('click', function (e) {
        e.preventDefault();
        var offset = $(escapeSelector(this.getAttribute('href'))).offset().top;
        html.velocity('stop').velocity('scroll', {
          offset: offset  + 'px',
          mobileHA: false
        });
      });

      // Expand sidebar on post detail page by default, when post has a toc.
      var $tocContent = $('.post-toc-content');
      if (isDesktop() && CONFIG.sidebar === 'post') {
        if ($tocContent.length > 0 && $tocContent.html().trim().length > 0) {
          displaySidebar();
        }
      }
    });
  </script>




<script type="text/javascript">
    $(document).ready(function () {
        if (CONFIG.sidebar === 'always') {
            displaySidebar();
        }
    });
</script>


<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
  });
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>







<!-- lazyload -->
<script type="text/javascript" src="/js/lazyload.js"></script>
<script type="text/javascript">
    jQuery(function () {
        jQuery("#posts img").lazyload({
            placeholder: "/images/loading.gif",
            effect: "fadeIn"
        });
    });
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>
</html>