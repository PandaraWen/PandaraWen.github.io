<!doctype html>
<html class="theme-next use-motion ">
<head>
	<!--为了使用aevit的js，需要预先加载jquery_20150722-->
	<script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>
    

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>




<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.4"/>


    <meta name="description" content="一切皆为年少轻狂之诳语" />



  <meta name="keywords" content="Objective-C,iOS,开发," />





  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.4" />


<meta name="description" content="搬运自ChenYiLong’s Github。
题目来自sunnyxx的博客：《招聘一个靠谱的iOS》)
有个人修改


本Part整理 ChenYiLong 原文章中余下的部分相关的题目。">
<meta property="og:type" content="article">
<meta property="og:title" content="《招聘一个靠谱的iOS》— Part ⅠⅠ">
<meta property="og:url" content="http://pandara.xyz/2015/10/20/reliable_ios_2/index.html">
<meta property="og:site_name" content="Pandara's Zone">
<meta property="og:description" content="搬运自ChenYiLong’s Github。
题目来自sunnyxx的博客：《招聘一个靠谱的iOS》)
有个人修改


本Part整理 ChenYiLong 原文章中余下的部分相关的题目。">
<meta property="og:image" content="http://7ls0ue.com1.z0.glb.clouddn.com/2015/10/reliable_ios/ugly_code.png">
<meta property="og:image" content="http://7ls0ue.com1.z0.glb.clouddn.com/2015/10/20/reliable_ios2/clang.png">
<meta property="og:image" content="http://7ls0ue.com1.z0.glb.clouddn.com/2015/10/20/reliable_ios2/obj_struct.png">
<meta property="og:image" content="http://7ls0ue.com1.z0.glb.clouddn.com/2015/10/20/reliable_ios2/objc_struct.png">
<meta property="og:image" content="http://7ls0ue.com1.z0.glb.clouddn.com/2015/10/20/reliable_ios2/obj_struct3.png">
<meta property="og:updated_time" content="2015-10-23T09:54:37.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="《招聘一个靠谱的iOS》— Part ⅠⅠ">
<meta name="twitter:description" content="搬运自ChenYiLong’s Github。
题目来自sunnyxx的博客：《招聘一个靠谱的iOS》)
有个人修改


本Part整理 ChenYiLong 原文章中余下的部分相关的题目。">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: '',
    sidebar: 'hide'
  };
</script>

    <title> 《招聘一个靠谱的iOS》— Part ⅠⅠ // Pandara's Zone </title>
    <link rel="shortcut icon" type="image/x-icon" href="http://7ls0ue.com1.z0.glb.clouddn.com/pandara_zone/favico%202.ico" media="screen" /> 
    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
</head>
<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">
<!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->


  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?c5d0f36c537707dfe01cd190611c07b1";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>



<div class="container one-column page-post-detail">
    <div id="pandara-brand" class="my-brand">
      <div id="space-ship" class="pandara-image"></div>
      <div id="planet0" class="pandara-image"></div>
      <div id="earth" class="pandara-image"></div>
      <div id="planet1" class="pandara-image"></div>
      <div id="planet2" class="pandara-image"></div>
      <div id="planet3" class="pandara-image"></div>
      <div id="satellite" class="pandara-image"></div>
      <div id="planet4" class="pandara-image"></div>
      <div id="planet5" class="pandara-image"></div>
      <div id="planet6" class="pandara-image"></div>
    </div>
    <div class="headband"></div>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
        <div class="header-inner"><h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand" rel="start">
      <span class="logo">
        <i class="icon-logo"></i>
      </span>
      <span class="site-title">Pandara's Zone</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          
            <a href="/" rel="section">
              <i class="menu-item-icon icon-home"></i> <br />
              首页
            </a>
          
        </li>
      
        
        <li class="menu-item menu-item-categories">
          
            <a href="/categories" rel="section">
              <i class="menu-item-icon icon-categories"></i> <br />
              分类
            </a>
          
        </li>
      
        
        <li class="menu-item menu-item-about">
          
            <a href="/about.html" rel="section">
              <i class="menu-item-icon icon-about"></i> <br />
              (๑╹◡╹๑)
            </a>
          
        </li>
      
        
        <li class="menu-item menu-item-archives">
          
            <a href="/archives" rel="section">
              <i class="menu-item-icon icon-archives"></i> <br />
              归档
            </a>
          
        </li>
      
        
        <li class="menu-item menu-item-tags">
          
            <a href="/tags" rel="section">
              <i class="menu-item-icon icon-tags"></i> <br />
              标签
            </a>
          
        </li>
      
    </ul>
  

  
</nav>


        </div>
    </header>

    <main id="main" class="main">
        <div class="main-inner">
            <div id="content" class="content">
                

  <div id="posts" class="posts-expand">
    

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              《招聘一个靠谱的iOS》— Part ⅠⅠ
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-10-20T00:00:00+08:00" content="2015-10-20">
            2015-10-20
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a href="/categories/你丫才码农/" itemprop="url" rel="index"><span itemprop="name">你丫才码农</span></a></span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/10/20/reliable_ios_2/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2015/10/20/reliable_ios_2/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        

        
          <span id="busuanzi_container_page_pv">
            &nbsp; | &nbsp;
            访客
            <span id="busuanzi_value_page_pv">0</span>
          </span>
        

       

      </div>
    </header>

    <div class="post-body">

      
      

      
        <span itemprop="articleBody"><blockquote>
<ul>
<li>搬运自<a href="https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88/%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88%EF%BC%88%E4%B8%8A%EF%BC%89.md" target="_blank" rel="external">ChenYiLong’s Github</a>。</li>
<li>题目来自sunnyxx的博客：<a href="(http://blog.sunnyxx.com/2015/07/04/ios-interview/">《招聘一个靠谱的iOS》</a>)</li>
<li>有个人修改</li>
</ul>
</blockquote>
<p><br>本Part整理 ChenYiLong 原文章中余下的部分相关的题目。</p>
<a id="more"></a>
<h5 id="编码风格纠错">编码风格纠错</h5><p>原代码：<br><img src="http://7ls0ue.com1.z0.glb.clouddn.com/2015/10/reliable_ios/ugly_code.png" alt="image"></p>
<p><br>修改方法有很多种，现给出一种做示例：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h文件</span></span><br><span class="line"><span class="comment">// 这是第一种修改方法，后面会给出第二种修改方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, CYLSex) &#123;</span><br><span class="line">    CYLSexMan,</span><br><span class="line">    CYLSexWoman</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CYLUser</span> : <span class="title">NSObject</span>&lt;<span class="title">NSCopying</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">assign</span>) <span class="built_in">NSUInteger</span> age;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">assign</span>) CYLSex sex;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithName:(<span class="built_in">NSString</span> *)name age:(<span class="built_in">NSUInteger</span>)age sex:(CYLSex)sex;</span><br><span class="line">+ (instancetype)userWithName:(<span class="built_in">NSString</span> *)name age:(<span class="built_in">NSUInteger</span>)age sex:(CYLSex)sex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>下面对具体修改的地方，分两部分做下介绍：<strong>硬伤部分</strong> 和 <strong>优化部分</strong>。因为硬伤部分没什么技术含量，为了节省大家时间，放在后面讲，大神请直接看 <strong>优化部分</strong>。</p>
<p><br><strong>优化部分</strong><br>1.enum 建议使用 <code>NS_ENUM</code> 和 <code>NS_OPTIONS</code> 宏来定义枚举类型，参见官方的 <a href="https://developer.apple.com/library/ios/releasenotes/ObjectiveC/ModernizationObjC/AdoptingModernObjective-C/AdoptingModernObjective-C.html" target="_blank" rel="external">Adopting Modern Objective-C</a> 一文：<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个枚举</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, CYLSex) &#123;</span><br><span class="line">    CYLSexMan,</span><br><span class="line">    CYLSexWoman</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>关于性别定义，最严谨的做法可以这样：<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, CYLUserGender) &#123;</span><br><span class="line">    CYLUserGenderUnknown,</span><br><span class="line">    CYLUserGenderMale,</span><br><span class="line">    CYLUserGenderFemale,</span><br><span class="line">    CYLUserGenderNeuter</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><br>2.age 属性的类型：应避免使用基本类型，建议使用 Foundation 数据类型，对应关系如下：<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> -&gt; <span class="built_in">NSInteger</span></span><br><span class="line"><span class="keyword">unsigned</span> -&gt; <span class="built_in">NSUInteger</span></span><br><span class="line"><span class="keyword">float</span> -&gt; <span class="built_in">CGFloat</span></span><br><span class="line">动画时间 -&gt; <span class="built_in">NSTimeInterval</span></span><br></pre></td></tr></table></figure></p>
<p>同时考虑到 age 的特点，应使用 NSUInteger ，而非 int 。 这样做的是基于64-bit 适配考虑，详情可参考出题者的博文<a href="http://blog.sunnyxx.com/2014/12/20/64-bit-tips/" target="_blank" rel="external">《64-bit Tips》</a>。</p>
<p><br>3.如果工程项目非常庞大，需要拆分成不同的模块，可以在类、typedef宏命名的时候使用前缀。</p>
<p><br>4.doLogIn方法不应写在该类中：</p>
<p><br><del>虽然LogIn的命名不太清晰，但笔者猜测是login的意思， （勘误：Login是名词，LogIn 是动词，都表示登陆的意思。见：<a href="http://grammarist.com/spelling/log-in-login/" target="_blank" rel="external">Log in vs. login</a>）</del></p>
<p><br>登录操作属于业务逻辑，观察类名 UserModel ，以及属性的命名方式，该类应该是一个 Model 而不是一个“ MVVM 模式下的 ViewModel ”：</p>
<blockquote>
<p>无论是 MVC 模式还是 MVVM 模式，业务逻辑都不应当写在 Model 里：MVC 应在 C，MVVM 应在 VM。</p>
</blockquote>
<p><br>如果抛开命名规范，假设该类真的是 MVVM 模式里的 ViewModel ，那么 UserModel 这个类可能对应的是用户注册页面，如果有特殊的业务需求，比如： -logIn 对应的应当是注册并登录的一个 Button ，出现 -logIn 方法也可能是合理的。</p>
<p><br>5.doLogIn 方法命名不规范：添加了多余的动词前缀。 请牢记：</p>
<blockquote>
<p>如果方法表示让对象执行一个动作，使用动词打头来命名，注意不要使用 do，does 这种多余的关键字，动词本身的暗示就足够了。</p>
</blockquote>
<p><br>应为 -logIn （注意： Login 是名词， LogIn 是动词，都表示登陆。 见 <a href="http://grammarist.com/spelling/log-in-login/" target="_blank" rel="external">Log in vs. login</a>）</p>
<p><br>6.<code>-(id)initUserModelWithUserName: (NSString*)name withAge:(int)age;</code> 方法中不要用 <code>with</code> 来连接两个参数: <code>withAge:</code> 应当换为 <code>age:</code>，<code>age:</code> 已经足以清晰说明参数的作用，也不建议用 <code>andAge:</code>：通常情况下，即使有类似 <code>withA:withB:</code> 的命名需求，也通常是使用 <code>withA:andB:</code> 这种命名，用来表示方法执行了两个相对独立的操作（从设计上来说，这时候也可以拆分成两个独立的方法），它不应该用作阐明有多个参数，比如下面的：<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误，不要使用"and"来连接参数</span></span><br><span class="line">- (<span class="keyword">int</span>)runModalForDirectory:(<span class="built_in">NSString</span> *)path andFile:(<span class="built_in">NSString</span> *)name andTypes:(<span class="built_in">NSArray</span> *)fileTypes;</span><br><span class="line"><span class="comment">//错误，不要使用"and"来阐明有多个参数</span></span><br><span class="line">- (instancetype)initWithName:(<span class="built_in">CGFloat</span>)width andAge:(<span class="built_in">CGFloat</span>)height;</span><br><span class="line"><span class="comment">//正确，使用"and"来表示两个相对独立的操作</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)openFile:(<span class="built_in">NSString</span> *)fullPath withApplication:(<span class="built_in">NSString</span> *)appName andDeactivate:(<span class="built_in">BOOL</span>)flag;</span><br></pre></td></tr></table></figure></p>
<p>7.由于字符串值可能会改变，所以要把相关属性的“内存管理语义”声明为 copy 。</p>
<p><br>8.“性别”(sex）属性的：该类中只给出了一种“初始化方法” (initializer)用于设置“姓名”(Name)和“年龄”(Age)的初始值，那如何对“性别”(Sex）初始化？</p>
<p><br>Objective-C 有 designated 和 secondary 初始化方法的观念。 designated 初始化方法是提供所有的参数，secondary 初始化方法是一个或多个，并且提供一个或者更多的默认参数来调用 designated 初始化方法的初始化方法。举例说明：<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .m文件</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">CYLUser</span></span></span><br><span class="line"></span><br><span class="line">- (instancetype)initWithName:(<span class="built_in">NSString</span> *)name</span><br><span class="line">                         age:(<span class="built_in">NSUInteger</span>)age</span><br><span class="line">                         sex:(CYLSex)sex &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        _name = [name <span class="keyword">copy</span>];</span><br><span class="line">        _age = age;</span><br><span class="line">        _sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithName:(<span class="built_in">NSString</span> *)name</span><br><span class="line">                         age:(<span class="built_in">NSUInteger</span>)age &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> initWithName:name age:age sex:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>上面的代码中 initWithName:age:sex: 就是 designated 初始化方法，另外的是 secondary 初始化方法。因为仅仅是调用类实现的 designated 初始化方法。</p>
<p><br>因为出题者没有给出 .m 文件，所以有两种猜测：1：本来打算只设计一个 designated 初始化方法，但漏掉了“性别”(sex）属性。那么最终的修改代码就是上文给出的第一种修改方法。2：不打算初始时初始化“性别”(sex）属性，打算后期再修改，如果是这种情况，那么应该把“性别”(sex）属性设为 readwrite 属性，最终给出的修改代码应该是：<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h文件</span></span><br><span class="line"><span class="comment">// 第二种修改方法（基于第一种修改方法的基础上）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, CYLSex) &#123;</span><br><span class="line">    CYLSexMan,</span><br><span class="line">    CYLSexWoman</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CYLUser</span> : <span class="title">NSObject</span>&lt;<span class="title">NSCopying</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">assign</span>) <span class="built_in">NSUInteger</span> age;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readwrite</span>, <span class="keyword">assign</span>) CYLSex sex;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithName:(<span class="built_in">NSString</span> *)name age:(<span class="built_in">NSUInteger</span>)age sex:(CYLSex)sex;</span><br><span class="line">- (instancetype)initWithName:(<span class="built_in">NSString</span> *)name age:(<span class="built_in">NSUInteger</span>)age;</span><br><span class="line">+ (instancetype)userWithName:(<span class="built_in">NSString</span> *)name age:(<span class="built_in">NSUInteger</span>)age sex:(CYLSex)sex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p><code>.h</code> 中暴露 designated 初始化方法，是为了方便子类化 （参考 《禅与 Objective-C 编程艺术》）</p>
<p><br>9.按照接口设计的惯例，如果设计了“初始化方法” (initializer)，也应当搭配一个快捷构造方法。而快捷构造方法的返回值，建议为 instancetype，为保持一致性，init 方法和快捷构造方法的返回类型最好都用 instancetype。</p>
<p><br>10.如果基于第一种修改方法：既然该类中已经有一个“初始化方法” (initializer)，用于设置“姓名”(Name)、“年龄”(Age)和“性别”(Sex）的初始值: 那么在设计对应 @property 时就应该尽量使用不可变的对象：其三个属性都应该设为“只读”。用初始化方法设置好属性值之后，就不能再改变了。在本例中，仍需声明属性的“内存管理语义”。于是可以把属性的定义改成这样<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">assign</span>) <span class="built_in">NSUInteger</span> age;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">assign</span>) CYLSex sex;</span><br></pre></td></tr></table></figure></p>
<p>由于是只读属性，所以编译器不会为其创建对应的“设置方法”，即便如此，我们还是要写上这些属性的语义，以此表明初始化方法在设置这些属性值时所用的方式。要是不写明语义的话，该类的调用者就不知道初始化方法里会拷贝这些属性(name)，他们有可能会在调用初始化方法之前自行拷贝属性值。这种操作多余而且低效。</p>
<p><br>11.<code>initUserModelWithUserName</code> 如果改为 <code>initWithName</code> 会更加简洁，而且足够清晰。</p>
<p><br>12.<del>UserModel 如果改为 User 会更加简洁，而且足够清晰。</del>个人不认同原文。</p>
<p><br>13.<del>UserSex如果改为Sex 会更加简洁，而且足够清晰。</del>个人不认同原文。</p>
<p><br>14.<del>第二个 @property 中 assign 和 nonatomic 调换位置。 推荐按照下面的格式来定义属性</del><br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readwrite</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>习惯上修改某个属性的修饰符时，一般从属性名从右向左搜索需要修动的修饰符。最可能从最右边开始修改这些属性的修饰符，根据经验这些修饰符被修改的可能性从高到底应为：内存管理 &gt; 读写权限 &gt;原子操作。</p>
</blockquote>
<p><br>个人不认同原文。我的实际开发习惯中，nonatomic 可以说在 object property 中 99.9% 的情况都会使用，所以对我来说它不怎么重要。我的定义习惯是：<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>， <span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *name;</span><br></pre></td></tr></table></figure></p>
<p>习惯问题罢了。</p>
<p><br><strong>硬伤部分</strong></p>
<ol>
<li>在 - 和 (void) 之间应该有一个空格</li>
<li>enum 中驼峰命名法和下划线命名法混用错误：枚举类型的命名规则和函数的命名规则相同：命名时使用驼峰命名法，勿使用下划线命名法</li>
<li>enum 左括号前加一个空格，或者将左括号换到下一行</li>
<li>enum 右括号后加一个空格</li>
<li><code>UserModel :NSObject</code> 应为 <code>UserModel : NSObject</code>，也就是:右侧少了一个空格</li>
<li><code>@interface</code> 与 <code>@property</code> 属性声明中间应当间隔一行</li>
<li>两个方法定义之间不需要换行，有时为了区分方法的功能也可间隔一行，但示例代码中间隔了两行</li>
<li><code>-(id)initUserModelWithUserName: (NSString*)name withAge:(int)age;</code> 方法中方法名与参数之间多了空格。而且 - 与 (id) 之间少了空格</li>
<li><code>-(id)initUserModelWithUserName: (NSString*)name withAge:(int)age;</code> 方法中 <code>(NSString*)name</code>，应为 <code>(NSString *)name</code>，少了空格。</li>
</ol>
<h5 id="objc中向一个nil对象发送消息将会发生什么？">objc中向一个nil对象发送消息将会发生什么？</h5><p>在 Objective-C 中向 nil 发送消息是完全有效的——只是在运行时不会有任何作用:</p>
<p><br>1.如果一个方法返回值是一个对象，那么发送给nil的消息将返回0(nil)。例如：<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person *motherInlaw = [[aPerson spouse] mother];</span><br></pre></td></tr></table></figure></p>
<p>如果 spouse 对象为 nil，那么发送给 nil 的消息 mother 也将返回 nil。</p>
<p><br>2.如果方法返回值为指针类型，其指针大小为小于或者等于sizeof(void*)，float，double，long double 或者 long long 的整型标量，发送给 nil 的消息将返回0。</p>
<p><br>3.如果方法返回值为结构体,发送给 nil 的消息将返回0。结构体中各个字段的值将都是0。</p>
<p><br>4.如果方法的返回值不是上述提到的几种情况，那么发送给 nil 的消息的返回值将是未定义的。</p>
<p><br><strong>具体原因如下:</strong><br>objc是动态语言，每个方法在运行时会被动态转为消息发送，即：objc_msgSend(receiver, selector)。还是举个栗子，贴一个 objc 的源代码：<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime.h（类在runtime中的定义）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> objc_class &#123;</span><br><span class="line">  Class isa OBJC_ISA_<span class="built_in">AVAILABILITY</span>; <span class="comment">//isa指针指向Meta Class，因为Objc的类的本身也是一个Object，为了处理这个关系，runtime就创造了Meta Class，当给类发送[NSObject alloc]这样消息时，实际上是把这个消息发给了Class Object</span></span><br><span class="line">  <span class="preprocessor">#if !__OBJC2__</span></span><br><span class="line">  Class super_class OBJC2_UN<span class="built_in">AVAILABLE</span>; <span class="comment">// 父类</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *name OBJC2_UN<span class="built_in">AVAILABLE</span>; <span class="comment">// 类名</span></span><br><span class="line">  <span class="keyword">long</span> version OBJC2_UN<span class="built_in">AVAILABLE</span>; <span class="comment">// 类的版本信息，默认为0</span></span><br><span class="line">  <span class="keyword">long</span> info OBJC2_UN<span class="built_in">AVAILABLE</span>; <span class="comment">// 类信息，供运行期使用的一些位标识</span></span><br><span class="line">  <span class="keyword">long</span> instance_size OBJC2_UN<span class="built_in">AVAILABLE</span>; <span class="comment">// 该类的实例变量大小</span></span><br><span class="line">  <span class="keyword">struct</span> objc_ivar_list *ivars OBJC2_UN<span class="built_in">AVAILABLE</span>; <span class="comment">// 该类的成员变量链表</span></span><br><span class="line">  <span class="keyword">struct</span> objc_method_list **methodLists OBJC2_UN<span class="built_in">AVAILABLE</span>; <span class="comment">// 方法定义的链表</span></span><br><span class="line">  <span class="keyword">struct</span> objc_cache *cache OBJC2_UN<span class="built_in">AVAILABLE</span>; <span class="comment">// 方法缓存，对象接到一个消息会根据isa指针查找消息对象，这时会在method Lists中遍历，如果cache了，常用的方法调用时就能够提高调用的效率。</span></span><br><span class="line">  <span class="keyword">struct</span> objc_protocol_list *protocols OBJC2_UN<span class="built_in">AVAILABLE</span>; <span class="comment">// 协议链表</span></span><br><span class="line">  <span class="preprocessor">#endif</span></span><br><span class="line">  &#125; OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br></pre></td></tr></table></figure></p>
<p>objc在向一个对象发送消息时，runtime库会根据对象的isa指针找到该对象实际所属的类，然后在该类中的方法列表以及其父类方法列表中寻找方法运行，然后在发送消息的时候，objc_msgSend方法不会返回值，所谓的返回内容都是具体调用时执行的。 那么，回到本题，如果向一个nil对象发送消息，首先在寻找对象的isa指针时就是0地址返回了，所以不会出现任何错误。(?)</p>
<h5 id="objc中向一个对象发送消息[obj_foo]和objc_msgSend()函数之间有什么关系？">objc中向一个对象发送消息[obj foo]和objc_msgSend()函数之间有什么关系？</h5><p>方法编译之后就是objc_msgSend()函数调用。</p>
<p><br>我们用 clang 分析下，clang 提供一个命令，可以将Objective-C的源码改写成C++语言，借此可以研究下 <code>[obj foo]</code> 和 <code>objc_msgSend()</code> 函数之间有什么关系。</p>
<p><br>以下面的代码为例，由于 clang 后的代码达到了10万多行，为了便于区分，添加了一个叫 iOSinit 方法，<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  main.m</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#import <span class="title">"CYLTest.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        CYLTest *test = [[CYLTest alloc] init];</span><br><span class="line">        [test performSelector:(<span class="keyword">@selector</span>(iOSinit))];</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在终端中输入<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -rewrite-objc main<span class="variable">.m</span></span><br></pre></td></tr></table></figure></p>
<p>就可以生成一个main.cpp的文件，在最底端（10万4千行左右），可以看到：</p>
<p><br><img src="http://7ls0ue.com1.z0.glb.clouddn.com/2015/10/20/reliable_ios2/clang.png" alt="image"></p>
<p><br>我们可以看到大概是这样的：<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((<span class="keyword">void</span> ()(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> )objc_msgSend)((<span class="keyword">id</span>)obj, sel_registerName(<span class="string">"foo"</span>));</span><br></pre></td></tr></table></figure></p>
<p>也就是说，<strong><code>[obj foo]</code> 在objc动态编译时，会被转意为：<code>objc_msgSend(obj, @selector(foo))</code>。</strong></p>
<h5 id="什么时候会报unrecognized_selector的异常？">什么时候会报unrecognized selector的异常？</h5><p>简单来说，当调用该对象上某个方法，而该对象上没有实现这个方法的时候，可以通过“消息转发”进行解决。</p>
<p><br>简单流程如下，在上一题中也提到过，objc是动态语言，每个方法在运行时会被动态转为消息发送，即：objc_msgSend(receiver, selector)。</p>
<p><br>objc在向一个对象发送消息时，runtime库会根据对象的isa指针找到该对象实际所属的类，然后在该类中的方法列表以及其父类方法列表中寻找方法运行，如果，在最顶层的父类中依然找不到相应的方法时，程序在运行时会挂掉并抛出异常unrecognized selector sent to XXX 。但是在这之前，objc的运行时会给出三次拯救程序崩溃的机会：</p>
<p><br><strong>1.Method resolution</strong><br>objc运行时会调用 <code>+resolveInstanceMethod:</code> 或者 <code>+resolveClassMethod:</code>，让你有机会提供一个函数实现。如果你添加了函数，那运行时系统就会重新启动一次消息发送的过程，否则 ，运行时就会移到下一步，消息转发（Message Forwarding）。</p>
<p><br><strong>2.Fast forwarding</strong><br>如果目标对象实现了 <code>-forwardingTargetForSelector:</code>，Runtime 这时就会调用这个方法，给你把这个消息转发给其他对象的机会。 只要这个方法返回的不是nil和self，整个消息发送的过程就会被重启，当然发送的对象会变成你返回的那个对象。否则，就会继续Normal Fowarding。 这里叫Fast，只是为了区别下一步的转发机制。因为这一步不会创建任何新的对象，但下一步转发会创建一个NSInvocation对象，所以相对更快点。</p>
<p><br><strong>3.Normal forwarding</strong><br>这一步是Runtime最后一次给你挽救的机会。首先它会发送 <code>-methodSignatureForSelector:</code> 消息获得函数的参数和返回值类型。如果 <code>-methodSignatureForSelector:</code> 返回 nil，Runtime 则会发出 <code>-doesNotRecognizeSelector:</code> 消息，程序这时也就挂掉了。如果返回了一个函数签名，Runtime 就会创建一个 NSInvocation 对象并发送 <code>-forwardInvocation:</code> 消息给目标对象。</p>
<p><br>关于这部分可以查看在<a href="http://www.cnblogs.com/biosli/p/NSObject_inherit_2.html" target="_blank" rel="external">这篇 blog 中</a>查看更多。</p>
<h5 id="一个objc对象如何进行内存布局？（考虑有父类的情况）">一个objc对象如何进行内存布局？（考虑有父类的情况）</h5><p>1.所有父类的成员变量和自己的成员变量都会存放在该对象所对应的存储空间中.</p>
<p><br>2.一个对象内部都有一个isa指针，指向他的类对象，类对象中存放着本对象的</p>
<ul>
<li>对象方法列表（对象能够接收的消息列表，保存在它所对应的类对象中）</li>
<li>成员变量的列表</li>
<li>属性列表</li>
</ul>
<p>它内部也有一个isa指针指向元对象(meta class),元对象内部存放的是类方法列表,类对象内部还有一个 superclass 的指针，指向他的父类对象。</p>
<p><br>每个 Objective-C 对象都有相同的结构，如下图所示：</p>
<p><br><img src="http://7ls0ue.com1.z0.glb.clouddn.com/2015/10/20/reliable_ios2/obj_struct.png" alt="image"></p>
<p><br>翻译过来就是：</p>
<p><br><img src="http://7ls0ue.com1.z0.glb.clouddn.com/2015/10/20/reliable_ios2/objc_struct.png" alt="image"></p>
<p><br>根对象就是NSobject，它的 superclass 指针指向 nil</p>
<p><br>类对象既然称为对象，那它也是一个实例。类对象中也有一个 isa 指针指向它的元类(meta class)，即类对象是元类的实例。元类内部存放的是类方法列表，根元类的 isa 指针指向自己，superclass 指针指向 NSObject 类。看图：</p>
<p><br><img src="http://7ls0ue.com1.z0.glb.clouddn.com/2015/10/20/reliable_ios2/obj_struct3.png" alt="image"></p>
<h5 id="一个objc对象的isa的指针指向什么？有什么作用？">一个objc对象的isa的指针指向什么？有什么作用？</h5><p>指向他的类对象,从而可以找到对象上的方法</p>
<h5 id="下面的代码输出什么？">下面的代码输出什么？</h5><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Son</span> : <span class="title">Father</span></span></span><br><span class="line"> - (<span class="keyword">id</span>)init</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">         <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> class]));</span><br><span class="line">         <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="built_in">NSStringFromClass</span>([<span class="keyword">super</span> class]));</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><strong>答案：</strong>都输出 Son</p>
<p>NSStringFromClass([self class]) = Son<br>NSStringFromClass([super class]) = Son</p>
<p><br>这个题目主要是考察关于 Objective-C 中对 self 和 super 的理解。</p>
<p><br>我们都知道：self 是类的隐藏参数，指向当前调用方法的这个类的实例。那 super 呢？</p>
<p><br>很多人会想当然的认为“super 和 self 类似，应该是指向父类的指针吧！”。这是很普遍的一个误区。其实 super 是一个 Magic Keyword， 它本质是一个编译器标示符，和 self 是指向的同一个消息接受者！他们两个的不同点在于：super 会告诉编译器，调用 class 这个方法时，要去父类的方法，而不是本类里的。</p>
<p><br>上面的例子不管调用 <code>[self class]</code> 还是 <code>[super class]</code>，接受消息的对象都是当前 Son ＊xxx 这个对象。</p>
<p><br>当使用 self 调用方法时，会从当前类的方法列表中开始找，如果没有，就从父类中再找；而当使用 super 时，则从父类的方法列表中开始找。然后调用父类的这个方法。至于上面为什么没有输出父类名字，下面会给出答案。</p>
<p>如果在 Father 类中实现了 class，那么将会调用 Father 的 class，而不再试输出“Son”。</p>
<p><br>这也就是为什么说“不推荐在 init 方法中使用点语法”，如果想访问实例变量 iVar 应该使用下划线 _iVar ，而非点语法 self.iVar 。</p>
<p><br>点语法 self.iVar 的坏处就是子类有可能覆写 setter 。假设 Person 有一个子类叫 ChenPerson，这个子类专门表示那些姓“陈”的人。该子类可能会覆写 lastName 属性所对应的设置方法：<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  ChenPerson.m</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#import <span class="title">"ChenPerson.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ChenPerson</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@synthesize</span> lastName = _lastName;</span><br><span class="line"></span><br><span class="line">- (instancetype)init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"🔴类名与方法名：%s（在第%d行），描述：%@"</span>, __PRETTY_FUNCTION__, __LINE__, <span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> class]));</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"🔴类名与方法名：%s（在第%d行），描述：%@"</span>, __PRETTY_FUNCTION__, __LINE__, <span class="built_in">NSStringFromClass</span>([<span class="keyword">super</span> class]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setLastName:(<span class="built_in">NSString</span>*)lastName</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//设置方法一：如果setter采用是这种方式，就可能引起崩溃</span></span><br><span class="line"><span class="comment">//    if (![lastName isEqualToString:@"陈"])</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        [NSException raise:NSInvalidArgumentException format:@"姓不是陈"];</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    _lastName = lastName;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置方法二：</span></span><br><span class="line">    _lastName = <span class="string">@"陈"</span>;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"🔴类名与方法名：%s（在第%d行），描述：%@"</span>, __PRETTY_FUNCTION__, __LINE__, <span class="string">@"会调用这个方法,想一下为什么？"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>在基类 Person 的默认初始化方法中，可能会将姓氏设为空字符串。此时若使用点语法 self.lastName 也即 setter 设置方法，那么调用将会是子类的设置方法，如果在刚刚的 setter 代码中采用设置方法一，那么就会抛出异常，</p>
<p><br>为了方便采用打印的方式展示，究竟发生了什么，我们使用设置方法二</p>
<p><br>如果基类的代码是这样的：<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Person.m</span></span><br><span class="line"><span class="comment">//  nil对象调用点语法</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#import <span class="title">"Person.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line">- (instancetype)init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.lastName</span> = <span class="string">@""</span>;</span><br><span class="line">        <span class="comment">//NSLog(@"🔴类名与方法名：%s（在第%d行），描述：%@", __PRETTY_FUNCTION__, __LINE__, NSStringFromClass([self class]));</span></span><br><span class="line">        <span class="comment">//NSLog(@"🔴类名与方法名：%s（在第%d行），描述：%@", __PRETTY_FUNCTION__, __LINE__, self.lastName);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setLastName:(<span class="built_in">NSString</span>*)lastName</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"🔴类名与方法名：%s（在第%d行），描述：%@"</span>, __PRETTY_FUNCTION__, __LINE__, <span class="string">@"根本不会调用这个方法"</span>);</span><br><span class="line">    _lastName = <span class="string">@"炎黄"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>那么打印结果将会是这样：<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">🔴类名与方法名：-[ChenPerson setLastName:]（在第<span class="number">36</span>行），描述：会调用这个方法,想一下为什么？</span><br><span class="line">🔴类名与方法名：-[ChenPerson init]（在第<span class="number">19</span>行），描述：ChenPerson</span><br><span class="line">🔴类名与方法名：-[ChenPerson init]（在第<span class="number">20</span>行），描述：ChenPerson</span><br></pre></td></tr></table></figure></p>
<p>接下来让我们利用 runtime 的相关知识来验证一下 super 关键字的本质，使用clang重写命令:<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ clang -rewrite-objc test<span class="variable">.m</span></span><br></pre></td></tr></table></figure></p>
<p>将这道题目中给出的代码被转化为:<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__<span class="built_in">NSConstantStringImpl__var_folders_gm_0jk35cwn1d3326x0061qym280000gn_T_main_a5cecc_mi_0</span>, <span class="built_in">NSStringFromClass</span>(((Class (*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *)objc_msgSend)((<span class="keyword">id</span>)<span class="keyword">self</span>, sel_registerName(<span class="string">"class"</span>))));</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__<span class="built_in">NSConstantStringImpl__var_folders_gm_0jk35cwn1d3326x0061qym280000gn_T_main_a5cecc_mi_1</span>, <span class="built_in">NSStringFromClass</span>(((Class (*)(__rw_objc_super *, SEL))(<span class="keyword">void</span> *)objc_msgSendSuper)((__rw_objc_super)&#123; (<span class="keyword">id</span>)<span class="keyword">self</span>, (<span class="keyword">id</span>)class_getSuperclass(objc_getClass(<span class="string">"Son"</span>)) &#125;, sel_registerName(<span class="string">"class"</span>))));</span><br></pre></td></tr></table></figure></p>
<p>从上面的代码中，我们可以发现在调用 [self class] 时，会转化成 objc_msgSend函数。看下函数定义：<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> objc_msgSend(<span class="keyword">id</span> <span class="keyword">self</span>, SEL op, ...)</span><br></pre></td></tr></table></figure></p>
<p>我们把 self 做为第一个参数传递进去。</p>
<p><br>而在调用 [super class]时，会转化成 objc_msgSendSuper函数。看下函数定义：<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> objc_msgSendSuper(<span class="keyword">struct</span> objc_super *<span class="keyword">super</span>, SEL op, ...)</span><br></pre></td></tr></table></figure></p>
<p>第一个参数是 objc_super 这样一个结构体，其定义如下：<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_super &#123;</span><br><span class="line">       __unsafe_unretained <span class="keyword">id</span> receiver;</span><br><span class="line">       __unsafe_unretained Class super_class;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>结构体有两个成员，第一个成员是 receiver, 类似于上面的 objc_msgSend 函数第一个参数 self 。第二个成员是记录当前类的父类是什么。</p>
<p><br>所以，当调用 [self class] 时，实际先调用的是 objc_msgSend 函数，第一个参数是 Son 当前的这个实例，然后在 Son 这个类里面去找 - (Class)class 这个方法，没有，去父类 Father里找，也没有，最后在 NSObject 类中发现这个方法。而 - (Class)class的实现就是返回self的类别，故上述输出结果为 Son。</p>
<p><br>objc Runtime开源代码对- (Class)class方法的实现：<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (Class)class &#123;</span><br><span class="line">    <span class="keyword">return</span> object_getClass(<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而当调用 [super class] 时，会转换成 objc_msgSendSuper 函数。第一步先构造 objc_super 结构体，结构体第一个成员就是 self 。 第二个成员是 (id)class_getSuperclass(objc_getClass(“Son”)) , 实际该函数输出结果为 Father。</p>
<p><br>第二步是去 Father这个类里去找 - (Class)class，没有，然后去NSObject类去找，找到了。最后内部是使用 objc_msgSend(objc_super-&gt;receiver, @selector(class))去调用。</p>
<p><br>此时已经和[self class]调用相同了，故上述输出结果仍然返回 Son。</p>
<p><br>参看链接：<a href="http://chun.tips/" target="_blank" rel="external">刨根问底Objective－C Runtime（1）－ Self &amp; Super</a></p>
<h5 id="runtime_如何通过_selector_找到对应的_IMP_地址？（分别考虑类方法和实例方法）">runtime 如何通过 selector 找到对应的 IMP 地址？（分别考虑类方法和实例方法）</h5><p>每一个类对象中都一个方法列表，方法列表中记录着方法的名称，方法实现,以及参数类型，其实selector本质就是方法名称，通过这个方法名称就可以在方法列表中找到对应的方法实现。</p>
<h5 id="使用runtime_Associate方法关联的对象，需要在主对象dealloc的时候释放么？">使用runtime Associate方法关联的对象，需要在主对象dealloc的时候释放么？</h5><p>无论在MRC下还是ARC下均不需要。</p>
<p><br><a href="https://web.archive.org/web/20120818164935/http://developer.apple.com/library/ios/#/web/20120820002100/http://developer.apple.com/library/ios/documentation/cocoa/conceptual/objectivec/Chapters/ocAssociativeReferences.html" target="_blank" rel="external">2011年版本的Apple API 官方文档 - Associative References</a>一节中有一个MRC环境下的例子：<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在MRC下，使用runtime Associate方法关联的对象，不需要在主对象dealloc的时候释放</span></span><br><span class="line"><span class="comment">// 摘自2011年版本的Apple API 官方文档 - Associative References </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> overviewKey;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSArray</span> *array = [[<span class="built_in">NSArray</span> alloc] initWithObjects:<span class="string">@"One"</span>, <span class="string">@"Two"</span>, <span class="string">@"Three"</span>, <span class="literal">nil</span>];</span><br><span class="line"><span class="comment">// For the purposes of illustration, use initWithFormat: to ensure</span></span><br><span class="line"><span class="comment">// the string can be deallocated</span></span><br><span class="line"><span class="built_in">NSString</span> *overview = [[<span class="built_in">NSString</span> alloc] initWithFormat:<span class="string">@"%@"</span>, <span class="string">@"First three numbers"</span>];</span><br><span class="line"></span><br><span class="line">objc_setAssociatedObject (</span><br><span class="line">    array,</span><br><span class="line">    &amp;overviewKey,</span><br><span class="line">    overview,</span><br><span class="line">    OBJC_ASSO<span class="built_in">CIATION_RETAIN</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">[overview release];</span><br><span class="line"><span class="comment">// (1) overview valid</span></span><br><span class="line">[array release];</span><br><span class="line"><span class="comment">// (2) overview invalid</span></span><br></pre></td></tr></table></figure></p>
<p>文档中指出：</p>
<blockquote>
<p>At point 1, the string overview is still valid because the <code>OBJC_ASSOCIATION_RETAIN</code> policy specifies that the array retains the associated object. When the array is deallocated, however (at point 2), overview is released and so in this case also deallocated.<br>在（1）处，字符串 overview 仍然可用，因为策略 OBJC_ASSOCIATION_RETAIN 指定了该 array retain 那个被关联的对象。然而当数组被销毁，在（2）处，overview 就会被 release，并且同时被释放掉了。因为 retainCount 为0。</p>
</blockquote>
<p><br>我们可以看到，在 <code>[array release];</code> 之后，overview 就会被 release 释放掉了。</p>
<p><br>既然会被销毁，那么具体在什么时间点？</p>
<p><br>根据 <a href="https://developer.apple.com/videos/wwdc2011/#322-video" target="_blank" rel="external">WWDC 2011, Session 322 (第36分22秒)</a> 中发布的内存销毁时间表，被关联的对象在生命周期内要比对象本身释放的晚很多。它们会在被 NSObject -dealloc 调用的 object_dispose() 方法中释放。</p>
<p><br>对象的内存销毁时间表，分四个步骤：</p>
<p><br><strong>1.调用 -release ：引用计数变为零 </strong></p>
<ul>
<li>对象即将被销毁，生命周期即将结束.</li>
<li>不能再有新的 __weak 弱引用， 否则将指向 nil.</li>
<li>调用 [self dealloc] </li>
</ul>
<p><br><strong>2.父类 调用 -dealloc</strong></p>
<ul>
<li>继承关系中最底层的父类 调用 -dealloc</li>
<li>如果是 MRC 代码 则会手动释放实例变量们（iVars）</li>
<li>继承关系中每一层的父类 都调用 -dealloc</li>
</ul>
<p><br><strong>3.NSObject 调 -dealloc</strong></p>
<ul>
<li>只做一件事：调用 Objective-C runtime 中的 object_dispose() 方法</li>
</ul>
<p><br><strong>4.调用 object_dispose()</strong></p>
<ul>
<li>为 C++ 的实例变量们（iVars）调用 destructors</li>
<li>为 ARC 状态下的 实例变量们（iVars） 调用 -release </li>
<li>解除所有使用 runtime Associate方法关联的对象</li>
<li>解除所有 __weak 引用</li>
<li>调用 free()</li>
</ul>
<p><br>对象的内存销毁时间表，<a href="http://stackoverflow.com/questions/10842829/will-an-associated-object-be-released-automatically/10843510#10843510" target="_blank" rel="external">来自 Stack Overflow 的回答</a></p>
<h5 id="objc_中的类方法和实例方法有什么本质区别和联系？">objc 中的类方法和实例方法有什么本质区别和联系？</h5><p><strong>类方法：</strong></p>
<ol>
<li>类方法是属于类对象的</li>
<li>类方法只能通过类对象调用</li>
<li>类方法中的self是类对象</li>
<li>类方法可以调用其他的类方法</li>
<li>类方法中不能访问成员变量</li>
<li>类方法中不能直接调用对象方法</li>
</ol>
<p><br><strong>实例方法</strong></p>
<ol>
<li>实例方法是属于实例对象的</li>
<li>实例方法只能通过实例对象调用</li>
<li>实例方法中的self是实例对象</li>
<li>实例方法中可以访问成员变量</li>
<li>实例方法中直接调用实例方法</li>
<li>实例方法中也可以调用类方法(通过类名)</li>
</ol>
<p><br><br>以上</p>
</span>
      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Objective-C/" rel="tag">#Objective-C</a>
          
            <a href="/tags/iOS/" rel="tag">#iOS</a>
          
            <a href="/tags/开发/" rel="tag">#开发</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-prev post-nav-item">
            
              <a href="/2015/10/21/reliable_ios_3/" rel="prev">《招聘一个靠谱的iOS》— Part ⅠⅠⅠ</a>
            
          </div>

          <div class="post-nav-next post-nav-item">
            
              <a href="/2015/10/19/Le_Petit_Prince/" rel="next">小王子</a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


            </div>

            

            
              <div class="comments" id="comments">
                
                  <div class="ds-thread" data-thread-key="2015/10/20/reliable_ios_2/"
                       data-title="《招聘一个靠谱的iOS》— Part ⅠⅠ" data-url="http://pandara.xyz/2015/10/20/reliable_ios_2/">
                  </div>
                
              </div>
            
        </div>

        
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <div class="site-author-avatar"></div>
          <p class="site-author-name" itemprop="name">Pandara</p>
        </div>
        <p class="site-description motion-element" itemprop="description">一切皆为年少轻狂之诳语</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">66</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="/categories">
              <span class="site-state-item-count">8</span>
              <span class="site-state-item-name">分类</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">39</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/PandaraWen" target="_blank">Github</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/pandarawen" target="_blank">Weibo</a>
              </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
            <p class="site-author-name">基情链接</p>
            
              <span class="links-of-author-item">
              <a href="http://aevit.xyz/" target="_blank">Aevit's Lab</a>
              </span>
            
              <span class="links-of-author-item">
              <a href="http://helkyle.com/" target="_blank">HelKyle's blog</a>
              </span>
            
              <span class="links-of-author-item">
              <a href="http://w3ctrain.com" target="_blank">W3cTrain</a>
              </span>
            
          
        </div>

      </section>

      
        <section class="post-toc-wrap sidebar-panel-active">
          <div class="post-toc-indicator-top post-toc-indicator"></div>
          <div class="post-toc">
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-5"><a class="nav-link" href="#编码风格纠错"><span class="nav-number">1.</span> <span class="nav-text">编码风格纠错</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#objc中向一个nil对象发送消息将会发生什么？"><span class="nav-number">2.</span> <span class="nav-text">objc中向一个nil对象发送消息将会发生什么？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#objc中向一个对象发送消息[obj_foo]和objc_msgSend()函数之间有什么关系？"><span class="nav-number">3.</span> <span class="nav-text">objc中向一个对象发送消息[obj foo]和objc_msgSend()函数之间有什么关系？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#什么时候会报unrecognized_selector的异常？"><span class="nav-number">4.</span> <span class="nav-text">什么时候会报unrecognized selector的异常？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#一个objc对象如何进行内存布局？（考虑有父类的情况）"><span class="nav-number">5.</span> <span class="nav-text">一个objc对象如何进行内存布局？（考虑有父类的情况）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#一个objc对象的isa的指针指向什么？有什么作用？"><span class="nav-number">6.</span> <span class="nav-text">一个objc对象的isa的指针指向什么？有什么作用？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#下面的代码输出什么？"><span class="nav-number">7.</span> <span class="nav-text">下面的代码输出什么？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#runtime_如何通过_selector_找到对应的_IMP_地址？（分别考虑类方法和实例方法）"><span class="nav-number">8.</span> <span class="nav-text">runtime 如何通过 selector 找到对应的 IMP 地址？（分别考虑类方法和实例方法）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#使用runtime_Associate方法关联的对象，需要在主对象dealloc的时候释放么？"><span class="nav-number">9.</span> <span class="nav-text">使用runtime Associate方法关联的对象，需要在主对象dealloc的时候释放么？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#objc_中的类方法和实例方法有什么本质区别和联系？"><span class="nav-number">10.</span> <span class="nav-text">objc 中的类方法和实例方法有什么本质区别和联系？</span></a></li></ol></div>
            
          </div>
          <div class="post-toc-indicator-bottom post-toc-indicator"></div>
        </section>
      

      <div class="side-bar-foot-decorate">
        <div class="side-bar-man motion-element"></div>
        <div class="side-bar-star motion-element"></div>
      </div>
    </div>
  </aside>


    </main>

    <footer id="footer" class="footer">
        <div class="footer-inner">
            <div class="copyright" >
  
  &copy; &nbsp; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="icon-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Pandara</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT
  </a>
</div>



        </div>
    </footer>

    <div class="back-to-top"></div>
</div>

  
  
  
    

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"pandara"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>
    

    
  
  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.4"></script>
  <script type="text/javascript" src="/js/fancybox-aevit.js"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.4"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.4" id="motion.global"></script>



  <script type="text/javascript" src="/js/search-toggle.js"></script>


  
<script type="text/javascript" src="/js/bootstrap.scrollspy.js?v=0.4.4" id="bootstrap.scrollspy.custom"></script>


<script type="text/javascript" id="sidebar.toc.highlight">
  $(document).ready(function () {
    var tocSelector = '.post-toc';
    var $tocSelector = $(tocSelector);
    var activeCurrentSelector = '.active-current';

    $tocSelector
      .on('activate.bs.scrollspy', function () {
        var $currentActiveElement = $(tocSelector + ' .active').last();

        removeCurrentActiveClass();
        $currentActiveElement.addClass('active-current');

        $tocSelector[0].scrollTop = $currentActiveElement.position().top;
      })
      .on('clear.bs.scrollspy', function () {
        removeCurrentActiveClass();
      });

    function removeCurrentActiveClass () {
      $(tocSelector + ' ' + activeCurrentSelector)
        .removeClass(activeCurrentSelector.substring(1));
    }

    function processTOC () {
      getTOCMaxHeight();
      toggleTOCOverflowIndicators();
    }

    function getTOCMaxHeight () {
      var height = $('.sidebar').height() -
                   $tocSelector.position().top -
                   $('.post-toc-indicator-bottom').height();

      $tocSelector.css('height', height);

      return height;
    }

    function toggleTOCOverflowIndicators () {
      tocOverflowIndicator(
        '.post-toc-indicator-top',
        $tocSelector.scrollTop() > 0 ? 'show' : 'hide'
      );

      tocOverflowIndicator(
        '.post-toc-indicator-bottom',
        $tocSelector.scrollTop() >= $tocSelector.find('ol').height() - $tocSelector.height() ? 'hide' : 'show'
      )
    }

    $(document).on('sidebar.motion.complete', function () {
      processTOC();
    });

    $('body').scrollspy({ target: tocSelector });
    $(window).on('resize', function () {
      if ( $('.sidebar').hasClass('sidebar-active') ) {
        processTOC();
      }
    });

    onScroll($tocSelector);

    function onScroll (element) {
      element.on('mousewheel DOMMouseScroll', function (event) {
          var oe = event.originalEvent;
          var delta = oe.wheelDelta || -oe.detail;
          var self = this;

          this.scrollTop += ( delta < 0 ? 1 : -1 ) * 30;
          event.preventDefault();

          toggleTOCOverflowIndicators();
      });
    }

    function tocOverflowIndicator (indicator, action) {
      $(indicator).velocity('stop').velocity({
        opacity: action === 'show' ? 0.4 : 0
      }, { duration: 100 });
    }

  });
</script>


  <script type="text/javascript" id="sidebar.nav">
    $(document).ready(function () {
      var html = $('html');

      $('.sidebar-nav li').on('click', function () {
        var item = $(this);
        var activeTabClassName = 'sidebar-nav-active';
        var activePanelClassName = 'sidebar-panel-active';
        if (item.hasClass(activeTabClassName)) {
          return;
        }

        var currentTarget = $('.' + activePanelClassName);
        var target = $('.' + item.data('target'));

        currentTarget.velocity('transition.slideUpOut', 200, function () {
          target
            .velocity('stop')
            .velocity('transition.slideDownIn', 200)
            .addClass(activePanelClassName);
        });

        item.siblings().removeClass(activeTabClassName);
        item.addClass(activeTabClassName);
      });

      $('.post-toc a').on('click', function (e) {
        e.preventDefault();
        var offset = $(escapeSelector(this.getAttribute('href'))).offset().top;
        html.velocity('stop').velocity('scroll', {
          offset: offset  + 'px',
          mobileHA: false
        });
      });

      // Expand sidebar on post detail page by default, when post has a toc.
      var $tocContent = $('.post-toc-content');
      if (isDesktop() && CONFIG.sidebar === 'post') {
        if ($tocContent.length > 0 && $tocContent.html().trim().length > 0) {
          displaySidebar();
        }
      }
    });
  </script>




<script type="text/javascript">
    $(document).ready(function () {
        if (CONFIG.sidebar === 'always') {
            displaySidebar();
        }
    });
</script>








<!-- lazyload -->
<script type="text/javascript" src="/js/lazyload.js"></script>
<script type="text/javascript">
    jQuery(function () {
        jQuery("#posts img").lazyload({
            placeholder: "/images/loading.gif",
            effect: "fadeIn"
        });
    });
</script>
</body>
</html>