<!doctype html>
<html class="theme-next use-motion ">
<head>
	<!--为了使用aevit的js，需要预先加载jquery_20150722-->
	<script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>
    

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>




<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.4"/>


    <meta name="description" content="一切皆为年少轻狂之诳语" />



  <meta name="keywords" content="iOS,Objective-C,runLoop," />





  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.4" />


<meta name="description" content="🐴的，经常看见大神们的文章提到 RunLoop，找了一些网上的文章都看得不明不白。无法可施，还是翻译一下苹果的官方文档吧。  另外推荐看 Ibireme 的这篇文章：深入理解RunLoop，比官方文档易懂很多。还有 孙源@sunnyxx 的视频：优酷链接">
<meta name="keywords" content="iOS,Objective-C,runLoop">
<meta property="og:type" content="article">
<meta property="og:title" content="Run Loops">
<meta property="og:url" content="http://pandara.xyz/2015/12/17/Run Loops/index.html">
<meta property="og:site_name" content="Pandara&#39;s Zone">
<meta property="og:description" content="🐴的，经常看见大神们的文章提到 RunLoop，找了一些网上的文章都看得不明不白。无法可施，还是翻译一下苹果的官方文档吧。  另外推荐看 Ibireme 的这篇文章：深入理解RunLoop，比官方文档易懂很多。还有 孙源@sunnyxx 的视频：优酷链接">
<meta property="og:image" content="http://7ls0ue.com1.z0.glb.clouddn.com/2015/12/15/run_loops/runloop.jpg">
<meta property="og:image" content="http://7ls0ue.com1.z0.glb.clouddn.com/2015/12/15/run_loops/custominputsource.jpg">
<meta property="og:updated_time" content="2015-12-18T04:17:03.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Run Loops">
<meta name="twitter:description" content="🐴的，经常看见大神们的文章提到 RunLoop，找了一些网上的文章都看得不明不白。无法可施，还是翻译一下苹果的官方文档吧。  另外推荐看 Ibireme 的这篇文章：深入理解RunLoop，比官方文档易懂很多。还有 孙源@sunnyxx 的视频：优酷链接">
<meta name="twitter:image" content="http://7ls0ue.com1.z0.glb.clouddn.com/2015/12/15/run_loops/runloop.jpg">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: '',
    sidebar: 'hide'
  };
</script>

    <title> Run Loops // Pandara's Zone </title>
    <link rel="shortcut icon" type="image/x-icon" href="http://7ls0ue.com1.z0.glb.clouddn.com/pandara_zone/favico%202.ico" media="screen" /> 
    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
</head>
<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">
<!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->


  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?c5d0f36c537707dfe01cd190611c07b1";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>



<div class="container one-column page-post-detail">
    <div id="pandara-brand" class="my-brand">
      <div id="space-ship" class="pandara-image"></div>
      <div id="planet0" class="pandara-image"></div>
      <div id="earth" class="pandara-image"></div>
      <div id="planet1" class="pandara-image"></div>
      <div id="planet2" class="pandara-image"></div>
      <div id="planet3" class="pandara-image"></div>
      <div id="satellite" class="pandara-image"></div>
      <div id="planet4" class="pandara-image"></div>
      <div id="planet5" class="pandara-image"></div>
      <div id="planet6" class="pandara-image"></div>
    </div>
    <div class="headband"></div>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
        <div class="header-inner"><h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand" rel="start">
      <span class="logo">
        <i class="icon-logo"></i>
      </span>
      <span class="site-title">Pandara's Zone</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          
            <a href="/" rel="section">
              <i class="menu-item-icon icon-home"></i> <br />
              首页
            </a>
          
        </li>
      
        
        <li class="menu-item menu-item-categories">
          
            <a href="/categories" rel="section">
              <i class="menu-item-icon icon-categories"></i> <br />
              分类
            </a>
          
        </li>
      
        
        <li class="menu-item menu-item-about">
          
            <a href="/about.html" rel="section">
              <i class="menu-item-icon icon-about"></i> <br />
              (๑╹◡╹๑)
            </a>
          
        </li>
      
        
        <li class="menu-item menu-item-archives">
          
            <a href="/archives" rel="section">
              <i class="menu-item-icon icon-archives"></i> <br />
              归档
            </a>
          
        </li>
      
        
        <li class="menu-item menu-item-tags">
          
            <a href="/tags" rel="section">
              <i class="menu-item-icon icon-tags"></i> <br />
              标签
            </a>
          
        </li>
      
    </ul>
  

  
</nav>


        </div>
    </header>

    <main id="main" class="main">
        <div class="main-inner">
            <div id="content" class="content">
                

  <div id="posts" class="posts-expand">
    

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              Run Loops
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-17T00:00:00+08:00" content="2015-12-17">
            2015-12-17
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a href="/categories/你丫才码农/" itemprop="url" rel="index"><span itemprop="name">你丫才码农</span></a></span>

              
              

            
          </span>
        

        
          <span id="busuanzi_container_page_pv">
            &nbsp; | &nbsp;
            访客
            <span id="busuanzi_value_page_pv">0</span>
          </span>
        

       

      </div>
    </header>

    <div class="post-body">

      
      

      
        <span itemprop="articleBody"><blockquote>
<p>🐴的，经常看见大神们的文章提到 RunLoop，找了一些网上的文章都看得不明不白。无法可施，还是翻译一下苹果的<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html" target="_blank" rel="external">官方文档</a>吧。</p>
</blockquote>
<p><br>另外推荐看 Ibireme 的这篇文章：<a href="http://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="external">深入理解RunLoop</a>，比官方文档易懂很多。<br><br>还有 孙源@sunnyxx 的视频：<a href="http://v.youku.com/v_show/id_XODgxODkzODI0.html" target="_blank" rel="external">优酷链接</a></p>
<a id="more"></a>
<p><br>Run loops 是跟线程相关联的底层结构。一个 run loop 是一个<strong>事件处理循环(event processing loop)</strong>，我们可以用它来执行工作，还有处理接收到的事件。Run loop 的目的是为了让你的线程在有任务需要处理时保持 busy，在空闲时进入 sleep 状态以免占用资源。</p>
<p><br>Run loop 机制并不是完全自动的。你需要设计你线程相关的代码来在合适的时间开始一个 run loop 并且响应到来的事件。Cocoa 跟 Core Foundation 都提供了相应的 run loop 对象来帮助你设置并且管理线程的 run loop。你的程序不需要显式创建他们。每一个线程，包括 app 的主线程，都有一个关联的 run loop 对象。只有<strong>二级线程(secondary thread)</strong>需要显式运行它们的 run loop。作为 app 启动操作的一部分，app framework 会自动在主线程设置并且运行 run loop。</p>
<p><br>相关链接：<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSRunLoop_Class/index.html#//apple_ref/doc/uid/TP40003725" target="_blank" rel="external">NSRunLoop Class Reference</a>, <a href="https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFRunLoopRef/index.html#//apple_ref/doc/uid/20001441" target="_blank" rel="external">CFRunLoop Reference</a></p>
<h5 id="Run_loop_剖析">Run loop 剖析</h5><p>一个 run loop 就像它的名字听起来那样，它是一个循环。而你的线程会进入这个循环并且使用它来处理一些事件。你的代码里面应该提供<strong>控制语句</strong>来实现 run loop 的循环部分——也就是说，代码中需要使用 <code>while</code> 或者 <code>for</code> 循环来驱动这个 run loop。在这个循环中，你将使用一个 run loop 对象来运行事件处理代码(event-processing)——接受时间并且调用相应的方法。</p>
<p><br>一个 run loop 接收事件的来源有两种。<strong>输入源(input source)</strong>会传递异步事件，通常会是来自其他线程或者是 app 的 message。<strong>定时器源(timer source)</strong>传递同步时间，会在计划时间点或者重复的时间间隔中发出。两种类型的事件源都会在事件到来时，使用一种<strong>程序指定的处理规则(application-specific handler routine)</strong>来处理事件。</p>
<p><br>下表展示了一个 run loop 还有两种来源的核心结构。输入源传递异步事件到相应的方法，并且调用 <code>runUntilDate:</code> 方法(在线程关联的 <code>NSRunLoop</code> 对象上调用)来(让 run loop？？？)退出。定时器源传递事件到相应的 handler 中，但是不会引起 run loop 退出。</p>
<p><br><img src="http://7ls0ue.com1.z0.glb.clouddn.com/2015/12/15/run_loops/runloop.jpg" alt="image"></p>
<p><br>除了处理输入源，run loops 也会生成一些关于 run loop 的行为的消息。已注册的 run-loop observer 可以接收到这些消息，并且使用它们来在线程中做一些额外的操作。可以使用 Core Foundation 来在你的线程中注册 run-loop observer。</p>
<h5 id="Run_loop_的模式">Run loop 的模式</h5><p>一个 run loop 的模式描述了输入源跟定时器源如何被监听，还有 run loop observer 如何被通知。每一次运行你的 run loop，你都将指定(包括显式或者隐式)一种特定的运行模式。在传递消息的过程中，只有关联该运行模式的 source 才会被监听到，它们才能传递它们的事件。类似地，只有关联了该模式的 observer 接收到 run loop 的通知。关联其他模式的 source 将会 hold on 所有新事件，直到有合适模式的 loop，才会将时间传递过去。</p>
<p><br>在你的代码中，将通过名称来识别不同的模式。Cocoa 跟 Core Foundatin 定义了默认模式跟及几种常用的模式。你也可以自己命名并且使用自定义的模式。虽然你自定模式时取名可以任意取，但是那些模式的内容可不是任意的。你必须确保添加了一个或者多个 source，timer，或者 run-loop observer 到你创建的模式中。</p>
<p><br>使用模式来将不需要的 source 的事件过滤掉。大部分情况下，你都会在系统定义的 default mode 下运行你的 run loop。但是一个<strong>模型模板(modal panel)</strong>可能会在 modal mode 中运行。当在这种模式中，只有与 modal panel 相关的 source 会传递时间到线程中。对于二级线程来说，你可能会使用自定义的 mode 来阻止低优先级的 source 在 time-critical 操作中传递事件。</p>
<blockquote>
<p>注意：模式是根据事件的来源(就是上文提到的 source)的类型来区分的，而不是根据事件的类型。例如，你不能使用某种模式来匹配鼠标点击的事件或者键盘事件。你可以使用模式来监听不同的端口集合、暂时挂起定时器，或者改变 source 跟 run loop observer。</p>
</blockquote>
<p><br>下表列出了 Cocoa 跟 Core Foundation 定义的集中标准模式。</p>
<table>
<thead>
<tr>
<th>Mode</th>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Default</td>
<td><code>NSDefaultRunLoopModel</code>, <code>kCFRunLoopDefaultModel</code></td>
<td>大部分情况下都会使用这种模式。大多数情况下，你应该使用这种模式来开始你的 run loop 还有设置你的输入源</td>
</tr>
<tr>
<td>Connection</td>
<td><code>NSConnectionReplyMode</code>(Cocoa)</td>
<td>Cocoa 使用这种模式与 <code>NSConnection</code> 对象相结合来监听 reply。你应该甚少会使用到这个 mode。</td>
</tr>
<tr>
<td>Modal</td>
<td><code>NSModalPanelRunLoopMode</code>(Cocoa)</td>
<td>Cocoa 使用这个模式来识别传递给 modal panel 的事件。</td>
</tr>
<tr>
<td>Event tracking</td>
<td><code>NSEventTrackingRunLoopMode</code></td>
<td>Cocoa 使用这个模式来限制在鼠标拖拽循环中即将到达的事件，同时还有其他 user interface tracking loops</td>
</tr>
<tr>
<td>Common modes</td>
<td><code>NSRunLoopCommonModes</code>(Cocoa), <code>KCFRunLoopCommonModes</code>(Core Foundation)</td>
<td>它代表一个可被设置的组，这个组里面包含一些通常会被使用的模式。关联这个模式的输入源就相当于关联了组里面的其他模式。对于 Cocoa 应用来说，这个组里面默认包含了 default, modal 跟 event tracking 三种模式。而 Core Foundation 中仅仅包含了 default 模式。你可以使用 <code>CFRunLoopAddCommonMode</code> 函数来添加自定义的模式。</td>
</tr>
</tbody>
</table>
<h5 id="输入源">输入源</h5><p>输入源异步传递事件到你的线程中。时间的 source 依赖于输入源的类型，通常是两种类型之一。<strong>基于端口(Port-based)</strong>的输入源监听 app 中匹配的端口。<strong>自定义(Custom)</strong>输入源监听自定义源。就你的 run loop 而言，一个输入源是 port-based 或者是 custom 的并不重要。系统会实现两种类型的输入源。两种输入源的唯一不同之处就是：它们是如何被分别的。Port-based 源由内核自动识别，自定义源则需要手动识别。</p>
<p><br>当你创建一个输入源后，便能将它分配给一个或者多个 run loop 模式。模式会影响在给定的时刻哪些 input source 会被响应。大多数情况下，你会在 default 模式下运行你的 run loop，但是你同时也可以指定自定义的模式。如果一个输入源不处于当前监听的模式，它生成的任何时间都会 hold 住，直到 run loop 在正确的模式下运行。</p>
<h6 id="Port-Based_Sources">Port-Based Sources</h6><p>Cocoa 跟 Core Foundation 通过 port-related 对象跟方法为创建 port-based 的输入源提供内建支持。例如，在 Cocoa 中，你永远不需要直接创建输入源。你只需要简单地创建一个 port 对象并且通过 <code>NSPort</code> 中的方法将 port 添加到 run loop 中。port 对象会创建你需要的输入源，并且配置好给你。</p>
<p><br>在 Core Foundation 中，你必须要手动创建 port 跟他的 run loop source。在两种情况中，你都需要使用跟 prot opaque type(<code>CFMachPortRef</code>, <code>CFMessagePortRef</code> 或者 <code>CFSocketRef</code>)相关联的函数来创建合适的对象。</p>
<h6 id="自定义输入源">自定义输入源</h6><p>要创建自定义输入源，你需要使用 Core Foundation 中跟 <code>CFRunLoopSourceRef</code> opaque type 相关联的方法。使用几个回调方法来配置输入源。Core Foundation 会在不同的时间按点调用这些方法来配置输入源、处理即将到来的时间，还有当一个 source 从 run loop 中被移除时将它销毁掉。</p>
<p><br>除了定义当事件来临时自定义源的行为之外，你还需要定义时间的传递机制。事件的传递机制会在几个独立的线程中运行，并且负责为输入源提供它的数据，还有当数据准备好可被处理时通知它。时间传递机制的实现完全取决于你，但是不应该太过复杂。</p>
<h6 id="Cocoa_Perform_Selector_Source">Cocoa Perform Selector Source</h6><p>除了 port-based sources 之外，Cocoa 定义了一种自定义输入源，允许你在任意的目标线程中执行方法。跟 port-based source 类似，执行方法的 request 在目标线程中是连续执行的，解决了大多数同步问题。这些问题通常会发生在，多个方法在同个线程中运行的情况。跟 port-based source 不同的是，perform selector source 在它执行完它的方法之后就会将自己从 run loop 中移除。</p>
<blockquote>
<p>注意：在 OS X v10.5 之前，perform selector sources 经常被用来向主线程发送消息，但是在 OS X v10.5 之后还有在 iOS 中，你可以使用它们来向任何线程发送消息。</p>
</blockquote>
<p><br>当在其他线程中实行 selector 时，目标线程需要有一个 active run loop。对于你创建的线程，这意味着你需要在代码中显式创建一个 run loop。由于主线程创建并运行了自己的 run loop，当应用在 appdelegate 中调用了 <code>applicationDidFinishLaunching:</code>，你便可以在主线程中开始一个 issuing call。所有 perform selector call 会在一个队列中存放起来，然后 run loop 会在每次循环的迭代中执行这些 call。而不是一次迭代执行一个。</p>
<p><br>下面列出了在 <code>NSObject</code> 中定义的方法，可以用来在其他线程中执行 selector。由于这些方法是在 <code>NSObject</code> 中声明的，你可以在任何能访问 Objective-C 对象的线程中使用它们，包括 POSIX 线程。这些方法实际上不会创建新的线程来执行 selector。</p>
<p><br><strong>performSelectorOnMainThread:withObject:waitUntilDone:</strong><br><strong>performSelectorOnMainThread:withObject:waitUntilDone:modes:</strong><br>在 app 的主线程的下一次 run loop 周期中执行指定的 selector。这些方法提供了设置，让你可以将当前线程阻塞，直到方法被执行。</p>
<p><br><strong>performSelector:onThread:withObject:waitUntilDone:</strong><br><strong>performSelector:onThread:withObject:waitUntilDone:modes:</strong><br>在你持有的 <code>NSThread</code> 对象的线程中执行指定的 selector。这些方法提供了设置，让你可以将当前线程阻塞，直到 selector 被执行。</p>
<p><br><strong>performSelector:withObject:afterDelay:</strong><br><strong>performSelector:withObject:afterDelay:inModes:</strong><br>在当前线程的下一个 run loop 循环中执行指定的 selector，这些方法提供了一个从当前执行代码开始的自动的最小延时(automatic mini delay)。多个在队列中的 selector 按照他们的顺序一个一个执行。</p>
<p><br><strong>cancelPreviousPerformRequestsWithTarget:</strong><br><strong>cancelPreviousPerformRequestsWithTarget:selector:object:</strong><br>让你可以取消使用上面一组方法发送到当前线程的消息。</p>
<h5 id="定时器源">定时器源</h5><p>定时器源同步地传递时间到你的线程中，按照预设的时间。Timer 是一种通知一个线程自己去执行一些任务的方法。例如，一个搜索框可以利用一个定时器来进行自动搜索。这样，用户可以在当想要的搜索结果出现时就停止输入。</p>
<p><br>虽然它生成基于时间的通知，但定时器并不是实时机制。跟输入源类似，定时器跟你的 run loop 的指定的模式相关联。如果一个定时器并所关联的模式跟当前被 run loop 监听的模式不匹配，它不会被触发，直到你运行一个该定时器支持的模式时，才会被触发。类似地，如果一个定时器在 run loop 正在执行到某个 handler 一半的时候被触发，timer 就会等待到下一次 run loop 来调用他的 handler。如果 run loop 压根就没有运行，那么定时器将永远不会被触发。</p>
<p><br>你可以设置定时器来生成一些时间，单次或者重复。一个重复的定时器自动根据设定的 firing time 来重新规划下次触发时间点，而不是实际上的触发时间点，就算实际的触发时间有延时。如果 firing time 被延后得太厉害，以至于它错过了一个或者多个被规划的 firing time，定时器对于被错失的时间段只会触发一次。对错过的时间段触发完成之后，timer 会继续按照设定的重复间隔重新设定下个 firing time。</p>
<h5 id="Run_Loop_Observer">Run Loop Observer</h5><p>跟 source 相反，source 在适当的同步或者异步时间发生时被触发，而 run loop observer 在 run loop 的执行过程中的特定位置触发。你可以使用 run loop observer 来准备你的线程来处理给定的事件，或者在线程进入休眠之前配置好它。你可以在你的 run loop 中将 run loop observer 跟下面的时间关联起来。</p>
<ul>
<li>开始进入 run loop</li>
<li>当 run loop 将要处理定时器</li>
<li>当 run loop 将要进入休眠</li>
<li>当 run loop 被唤醒，但是在开始处理唤醒它的时间之前</li>
<li>run loop 退出</li>
</ul>
<p><br>你可以使用 Core Foundation 来将 run loop observer 添加到 app。要创建一个 run loop observer，你可以创建一个 <code>CFRunLoopObserver</code> 类型的对象。它将 track 你的自定义回调，还有它感兴趣的活动。</p>
<p><br>跟定时器类似，run-loop observer 可以一次或者重复使用。one-shot observer 将在它被触发之后将自己从 run loop 中移除，而 repeating observer 则仍会跟 run loop 相关联。你可以在创建它的时候指定它是单次还是重复。</p>
<h5 id="事件的_Run_Loop_序列">事件的 Run Loop 序列</h5><p>每次运行的时候，你的线程的 run loop 会处理待处理的事件，并且生成通知去通知所有关联的 observer。它进行这些工作的顺序非常确定，如下：</p>
<ol>
<li>通知所有 observer，已经进入 run loop 了；</li>
<li>通知所有 observer，就绪的定时器将要 fire 了(如果有的话) ；</li>
<li>通知所有 observer，<strong>非 port-based input source</strong>将要 fire 了(如果有的话)；</li>
<li>fire 所有准备好 fire 的 non-port-based input source；</li>
<li>如果有一个 port-based input source 已经准备好并且在等待 fire，则马上执行它的事件，并且跳到 step 9；</li>
<li>通知所有 observer 线程准备进入休眠；</li>
<li>将线程休眠，直到有下面任何一种事件发生：</li>
</ol>
<ul>
<li>有一个 prot based input source 的时间到达；</li>
<li>有一个 timer fires；</li>
<li>run loop 的过期时间到了；</li>
<li>run loop 被显式唤醒；</li>
</ul>
<ol>
<li>通知所有 observer 线程刚被唤醒了；</li>
<li>执行所有待处理的事件：</li>
</ol>
<ul>
<li>如果一个用户定义的定时器 fire，处理那个定时器时间并且重新开始该 loop，跳到 step 2；</li>
<li>如果一个 input source fire，传递该事件；</li>
<li>如果 run loop 是被显式唤醒的，但并没有超时，重新开始该 loop，并跳到 step 2；</li>
</ul>
<ol>
<li>通知所有 observer run loop 已经退出了。</li>
</ol>
<p><br>由于发送给 observer 的关于 timer 跟 input source 的通知在那些事件实际发生之前就被传递了，所以通知发生的时间与事件实际上产生的时间之间可能会有间隔。如果事件的时间非常重要，你可以使用<strong> sleep </strong>跟<strong> awake-from-sleep </strong>的通知来帮助你将时间与实际事件之间关联起来。</p>
<p><br>由于定时器跟其他周期性事件是在你运行 run loop 的时候传递的，所以如果错过了 loop 将使那些时间的传递中断。典型的例子就是：你通过进入 loop 然后通过定时器不停地向 application 请求事件，来实现一个 mouse-tracking routine。由于你的代码直接抓取事件，而不是让 application 来正常分发这些事件，所以定时器将直到你的 mouse-tracking routine 退出并将控制权返还给 application 的时候才能触发。（？？？）</p>
<p><br>run loop 可以通过 run loop 对象被显式唤醒。其他事件也可能会造成 run loop 被唤醒。例如，添加其他 non-port-based 输入源会唤醒 run loop，好让输入源可以被立即处理，而不是要等到其他事件发生。</p>
<h5 id="什么时候能够使用_Run_Loop">什么时候能够使用 Run Loop</h5><p>仅仅当你为你的 application 创建二级线程的时候才需要显式运行 run loop。app 中主线程的 run loop 是基础架构中最重要的一部分。所以，app framework 提供了运行 main loop 的代码，并且自动开始运行该 loop。iOS 中 <code>UIApplication</code>(OS X 中是 <code>NSApplication</code>) 的 <code>run</code> 方法把“运行 app 的 main loop ”作为正常启动的操作序列的一部分，如果你使用 Xcode 的模板项目来创建 app，你应该永远都不需要显式调用这些操作。</p>
<p><br>对于二级线程来书，你需要决定是否需要创建一个 run loop，如果有需要的话，自行配置并开始它。在所有情况下，你都不需要创建一个线程的 run loop。例如，如果你使用线程来实行一些长时间运行并且预先决定的任务，那么大概你不应该使用 run loop。而当你希望与线程之间能有更多的交互的时候，可能你就需要一个 run loop。例如，在你打算执行下面这些操作的时候，你需要开始一个 run loop：</p>
<ul>
<li>使用 port-based 或者是自定义的输入源来跟其他线程之间进行信息传递；</li>
<li>在线程中使用 timer；</li>
<li>在 Cocoa app 中使用任何 <code>performSelector...</code> 方法；</li>
<li>需要将线程留存起来，来执行一些周期性的任务。</li>
</ul>
<p><br>如果你选择了要使用 run loop，配置跟设置的过程非常简单。跟所有线程相关的编程一样，你应该规划好在合适的情况下退出你的二级线程。最好能让线程自己退出，来干净地结束掉它，而不是强制它结束。</p>
<h5 id="使用_Run_Loop_对象">使用 Run Loop 对象</h5><p>run loop 对象提供了主要的接口来添加输入源、定时器还有 run-loop observer，然后运行该 loop。每一个线程都有一个 run loop 对象跟它关联。在<br>Cocoa，这个对象是 <code>NSRunLoop</code> 类的对象。而在低层应用中，它是 <code>CFRunLoopRef</code> 类型的指针。</p>
<h6 id="获取一个_Run_Loop_对象">获取一个 Run Loop 对象</h6><p>要获取当前线程的一个 run loop，你可以使用以下其一的方法：</p>
<ul>
<li>在 Cocoa 应用中，使用 <code>NSRunLoop</code> 的类方法 <code>currentRunLoop</code> 来取得一个 <code>NSRunLoop</code> 对象；</li>
<li>使用 <code>CFRunLoopGetCurrent</code> 函数。</li>
</ul>
<p><br>虽然他们并不是 toll-free<br> birdged type，但是你可以在需要的时候从 <code>NSRunLoop</code> 对象中取得 <code>CFRunLoopRef</code> 类型的对象。<code>NSRunLoop</code> 类定义了一个 <code>getCFRunLoop</code> 的方法来返回 <code>CFRunLoopRef</code> 对象，你可以将它传递到 Core Foundation 的代码中。由于两个类型的对象都指向同一个 run loop，你可以在需要的时候混合使用两种类型。</p>
<h6 id="配置_Run_Loop">配置 Run Loop</h6><p>在你为二级线程运行 run loop 之前，你需要至少添加一个输入源或者定时器到 run loop 中。如果一个 run loop 没有任何 source 可以监听，那么它将会在你试图运行它的时候马上退出。</p>
<p><br>除了添加源之外，你还可以添加 run loop observer，用来检测 run loop 的不同执行状态。添加 run loop observer，可使用 <code>CFRunLoopObserverRef</code> 类型并且使用 <code>CFRunLoopAddObserver</code> 函数。run loop observer 必须要使用 Core Foundation 来创建，即使是在 Cocoa 程序中。</p>
<p><br>下面的代码，展示了如何将线程的 run loop 跟 run loop observer 之间关联。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)threadMain</div><div class="line">&#123;</div><div class="line">	<span class="comment">//程序使用垃圾回收，所以不需要 autorelease pool</span></div><div class="line">	<span class="built_in">NSRunLoop</span> *myRunLoop = [<span class="built_in">NSRunLoop</span> currentRunLoop];</div><div class="line"></div><div class="line">	<span class="comment">//创建一个 run loop observer 然后将它与 run loop 之间关联</span></div><div class="line">	<span class="built_in">CFRunLoopObserverContext</span> context = &#123;<span class="number">0</span>, <span class="keyword">self</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;;</div><div class="line">	<span class="built_in">CFRunLoopObserverRef</span> observer = <span class="built_in">CFRunLoopObserverCreate</span>(</div><div class="line">			KCFAllocatorDefault,</div><div class="line">			kCFRunLoopAllActivities,</div><div class="line">			<span class="literal">YES</span>,</div><div class="line">			<span class="number">0</span>,</div><div class="line">			&amp;myRunLoopObserver,</div><div class="line">			&amp;context</div><div class="line">		);</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (observer) &#123;</div><div class="line">		<span class="built_in">CFRunLoopRef</span> cfLoop = [myRunLoop getCFRunLoop];</div><div class="line">		<span class="built_in">CFRunLoopAddObserver</span>(cfLoop, observer, kCFRunLoopDefaultMode);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">//创建并安排一个定时器</span></div><div class="line">	[<span class="built_in">NSTimer</span> scheduleTimerWithTimeInterval:<span class="number">0.1</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(doFireTimer:) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</div><div class="line"></div><div class="line">	<span class="built_in">NSInteger</span> loopCount = <span class="number">10</span>;</div><div class="line">	<span class="keyword">do</span> &#123;</div><div class="line">		<span class="comment">//将 run loop 运行10次来让定时器得以触发</span></div><div class="line">		[myRunLoop runUntilDate:[<span class="built_in">NSDate</span> dateWithTimeIntervalSinceNow:<span class="number">1</span>]];</div><div class="line">		loopCount--;</div><div class="line">	&#125; <span class="keyword">while</span>(loopCount);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当你为长期存在的线程配置 run loop 的时候，最好至少添加一个输入源来接受消息。虽然你可以在仅仅有一个定时器的情况下进入 run loop，一旦 timer 触发，之后某个时间点 invalidate 之后，会造成 run loop 退出。而添加重复的 timer 则可以让 run loop 留存更长的一段时间，但是会让你的线程周期性地被唤醒，这是另一种有效的轮询形式。相反而言，一个输入源等待事件的发生，在事件发生之前将一直让线程保持休眠。</p>
<h6 id="开始一个_Run_Loop">开始一个 Run Loop</h6><p>在你的程序中仅仅需要为二级线程开始一个 run loop。一个 run loop 必须最少有一个输入源或者定时器来监听。如果一个都没有关联到 run loop，那么 run loop 将马上退出。</p>
<p><br>有几种方法来开始一个 run loop，包含下面的方式：</p>
<ul>
<li>无任何条件；</li>
<li>设定一个时间限制；</li>
<li>以一种特殊的模式；</li>
</ul>
<p>以无条件的方式进入 run loop 是最简单的选择，但它能实现的功能也最少。以无条件的方式进入 run loop 会将线程放入到一个固定的 loop 中，而该 loop 仅提供给你很少的操控功能。你可以向它添加或者移除输入源，但仅有的一种停止 run loop 的方式是 kill。而且也没有方式可以在自定义模式下运行 run loop。</p>
<p><br>相比起无条件地运行 run loop，一种更好的运行方式是给 run loop 设置一个过期时间。当使用过期时间，run loop 会一直运行直到事件到达，或者指派的时间过期了。如果有一个事件到来了，那个时间会被分派到 handler 来处理，然后 run loop 就会退出。而你的代码随后可以重新开始该 run loop 来处理下一个事件。相反，如果是过期时间到了，你可以简单地重启 run loop 或者使用那个过期的时间来做一些处理。</p>
<p><br>除了过期时间之外，你还可以用特殊的模式来运行你的 run loop。模式还有过期时间的设置，两者之间并不是互斥的，他们可以同时使用。模式限制传递事件到 run loop 的 source 的类型。</p>
<p><br>下面的代码展示了进入线程的代码框架。这个例子的关键部分展示了 run loop 的基本结构。概括来说，代码将添加你的输入源还有定时器到 run loop 中，然后重复的让 run loop 再开始。每次 run loop 返回的时候，都检查一下某些条件是否已经达到了，是否可以退出线程了。样例使用了 Core Foundation run loop，所以可以检查返回的结果，然后知道为什么 run loop 退出。同样也可以使用 <code>NSRunLoop</code> 类以相同的方式来运行 run loop ，如果你正在使用 Cocoa 并且不需要检查返回的值。<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)skeletonThreadMain</div><div class="line">&#123;</div><div class="line">	<span class="comment">//如果你没有使用垃圾回收机制的话，在这里设置 autorelease pool</span></div><div class="line">	<span class="built_in">BOOL</span> done = <span class="literal">NO</span>;</div><div class="line"></div><div class="line">	<span class="comment">//将你的 source 或者定时器添加到 run loop 并且做一些其他的设置</span></div><div class="line">	<span class="keyword">do</span> &#123;</div><div class="line">		<span class="comment">//开始一个 run loop，但在 source 处理完成之后退出</span></div><div class="line">		SInt32 result = <span class="built_in">CFRunLoopRunInMode</span>(kCFRunLoopDefaultMode, <span class="number">10</span>, <span class="literal">YES</span>);</div><div class="line"></div><div class="line">		<span class="comment">//如果一个 source 显式停止了 run loop，或者没有</span></div><div class="line">		<span class="comment">//source 或者定时器，继续还有退出</span></div><div class="line">		<span class="keyword">if</span> ((result == KCFRunLoopRunStopped) || (result == kCFRunLoopRunFinished)) &#123;</div><div class="line">			done = <span class="literal">YES</span>;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">//在这里检测其他退出条件，并且如果需要的话设置变量 done 的值</span></div><div class="line"></div><div class="line">	&#125; <span class="keyword">while</span>(!done);</div><div class="line"></div><div class="line">	<span class="comment">//在这里清理代码，要确保释放任何分配了的 autorelease pool</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><br>你也可以递归地运行 run loop。换句话说，你可以调用 <code>CFRunLoopRun</code>, <code>CFRunLoopRunInMode</code>, 或者其他的 <code>NSRunLoop</code> 中的用于从 source 或者定时器的 handler 开始 run loop 的方法。当你这样做的时候，你可以使用任一种你想要的模式来运行 run loop，包括哪些在其他 run loop 中使用的模式。</p>
<h6 id="退出_run_loop">退出 run loop</h6><p>有两种方法可以让 run loop 在处理完一个事件之后退出 run loop：</p>
<ul>
<li>在运行 run loop 的时候设置一个过期时间；</li>
<li>直接让 run loop 退出。</li>
</ul>
<p><br>用过期时间来退出 run loop 应该是较常用的。指定一个过期时间，然后让 run loop 在退出之前完成它所有的正常处理操作，包括传递消息到 run loop observer。</p>
<p><br>显式调用 <code>CFRunLoopStop</code> 函数来产生停止 run loop，效果跟设置过期时间类似。run loop 会将所有剩下的通知发出去，然后退出。不同之处是，你可以对以无条件方式启动的 run loop 使用这个技术。</p>
<p><br>虽然将 run loop 的 input source 跟 定时器移除也可以引起 run loop 退出，但这并不是一种可靠的退出县城的方式。一些系统程序会添加 input resource 到 run loop 中来处理一些必要的事件。因为你的代码可能不会发现这些 source，所以也不能移除它们，而你的 run loop 也因此而不能退出。</p>
<h6 id="Run_Loop_对象跟线程安全">Run Loop 对象跟线程安全</h6><p>线程安全根据你用来控制你的 loop 的 API 而不同。Core Founcation 的函数通常是线程安全的，并且能被任何线程调用。但是如果你正在执行一些修改 run loop 的配置的操作，最好还是在该 run loop 对应的线程里面进行。</p>
<p><br>而 Cocoa 中的 <code>NSRunLoop</code> 类并不如它在 Core Foundation 中对应的部分一样线程安全。如果你在使用 <code>NSRunLoop</code> 类来修改你的 run loop，你应该只在该 run loop 对应的同个线程中进行。为属于其他线程的 run loop 添加输入源或者定时器可能会造成你的 app 崩溃或者出现 bug。</p>
<h5 id="配置_Run_Loop_Source">配置 Run Loop Source</h5><h6 id="定义自定义的输入源">定义自定义的输入源</h6><p>创建自定义的输入源需要定义下面这些：</p>
<ul>
<li>你希望你的输入源处理的信息；</li>
<li>scheduler 代码块，能让相关的 client 知道如何访问你的输入源；</li>
<li>handler 代码块，可以处理 client 发送的请求；</li>
<li>cancellation 代码块，可以取消你的输入源；</li>
</ul>
<p><br>由于你创建了一个自定义的输入源来处理自定义信息，所以实际上整个配置的流程被设计得很灵活。scheduler，handler 还有 cancellation 是你在创建自己的自定义输入源时重要的几个环节。然而大部分余下的输入源行为是在 handler 程序之外发生的。例如，如何定义向你的输入源传递数据还有如何让你的输入源与其他线程沟通，完全取决于你。</p>
<p><br>下表展示了一个样例，设置自定义的输入源。在这里例子中，app 的主线程保留一个指向输入源的的引用、一个自定义的命令缓冲区还有安装该输入源的 run loop。当主线程有一个想要在工作线程处理的任务，它会发送一个命令到命令缓冲区，该命令包含了工作线程开始它的任务所需要的信息。（由于主线程跟工作线程的输入源都拥有该命令缓冲区的引用，所以两者的访问需要被同步。）一旦命令被发送了，主线程会通知输入源，并且唤醒工作线程的 run loop。根据收到的唤醒命令，run loop 会为输入源调用 handler，来处理在 command buffer 中接收到的命令。</p>
<p><br><img src="http://7ls0ue.com1.z0.glb.clouddn.com/2015/12/15/run_loops/custominputsource.jpg" alt="image"></p>
<p><br>定义自定义的输入源需要使用 Core Foundation 相关的代码，来配置你的 run loop source，并且将它关联到 run loop。虽然 basic handler 是 C-based 函数，但是这不会妨碍你使用 Objective-C 或者 C++ 来实现你的代码。</p>
<p><br>上面的示意图中，使用一个 Objective-C 对象来管理命令缓冲区，还有跟 run loop 一起封装起来。再下面的一段代码则展示了如何定义这个对象。<code>RunLoopSource</code> 对象管理一个命令缓冲区，并且使用该命令缓冲区来接受来自其他线程的消息。同时展示了 <code>RunLoopContext</code> 的定义，它是用于传递 <code>RunLoopSource</code> 对象的容器，同时也是 app 的主线程的 run loop 引用。<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RunLoopSource</span> : <span class="title">NSObject</span></span></div><div class="line">&#123;</div><div class="line">	<span class="built_in">CFRunLoopSourceRef</span> runLoopSource;</div><div class="line">	<span class="built_in">NSMutableArray</span> *commands;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">id</span>)init;</div><div class="line">- (<span class="keyword">void</span>)addToCurrentRunLoop;</div><div class="line">- (<span class="keyword">void</span>)invalidate;</div><div class="line"></div><div class="line"><span class="comment">//handler method</span></div><div class="line">- (<span class="keyword">void</span>)sourceFired;</div><div class="line"></div><div class="line"><span class="comment">//Client interface, 向 process 注册 command</span></div><div class="line">- (<span class="keyword">void</span>)addCommand:(<span class="built_in">NSInteger</span>)command withData:(<span class="keyword">id</span>)data;</div><div class="line">- (<span class="keyword">void</span>)fireAllCommandsOnRunLoop:(<span class="built_in">CFRunLoopRef</span>)runloop;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="comment">//CFRunLoopSourceRef 的回调函数</span></div><div class="line"><span class="keyword">void</span> RunLoopSourceScheduleRoutine (<span class="keyword">void</span> *info, <span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFStringRef</span> mode);</div><div class="line"><span class="keyword">void</span> RunLoopSourcePerformRoutine (<span class="keyword">void</span> *info);</div><div class="line"><span class="keyword">void</span> RunLoopSourceCancelRoutine (<span class="keyword">void</span> *info, <span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFStringRef</span> mode);</div><div class="line"></div><div class="line"><span class="comment">//RunLoopContext 是一个在注册输入源时使用的容器对象</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RunLoopContext</span> : <span class="title">NSObject</span></span></div><div class="line">&#123;</div><div class="line">	<span class="built_in">CFRunLoopRef</span> runLoop;</div><div class="line">	RunLoopSource* source;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">CFRunLoopRef</span> runLoop;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) RunLoopSource* source;</div><div class="line"></div><div class="line">- (<span class="keyword">id</span>)initWithSource:(RunLoopSource*)src andLoop:(<span class="built_in">CFRunLoopRef</span>)loop;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>虽然上面的 Objective-C 代码管理输入源的自定义数据，但是将输入源关联到 run loop 需要基于 C 的回调函数。这些函数中的第一个在你将一个 run loop source 关联到 run loop 的时候被调用，如下面的代码所示。由于该 input source 只有一个 client（主线程），它使用一个 scheduler 该函数来向注册器自身发送消息。当 delegate 想要跟 input source 沟通，它需要使用 <code>RunLoopContext</code> 对象中的信息。</p>
<p>翻译到这里，我想知道的知道得差不多了，<br>待续。。。</p>
</span>
      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/iOS/" rel="tag">#iOS</a>
          
            <a href="/tags/Objective-C/" rel="tag">#Objective-C</a>
          
            <a href="/tags/runLoop/" rel="tag">#runLoop</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-prev post-nav-item">
            
              <a href="/2015/12/18/runloop2/" rel="prev">Run Loops II</a>
            
          </div>

          <div class="post-nav-next post-nav-item">
            
              <a href="/2015/12/16/nobody_alive/" rel="next">《无人生还》</a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


            </div>

            

            
              <div class="comments" id="comments">
                
                  <div id="disqus_thread">
                    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                  </div>
                
              </div>
            
        </div>

        
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <div class="site-author-avatar"></div>
          <p class="site-author-name" itemprop="name">Pandara</p>
        </div>
        <p class="site-description motion-element" itemprop="description">一切皆为年少轻狂之诳语</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">88</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="/categories">
              <span class="site-state-item-count">8</span>
              <span class="site-state-item-name">分类</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">43</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/PandaraWen" target="_blank">Github</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/pandarawen" target="_blank">Weibo</a>
              </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
            <p class="site-author-name">基情链接</p>
            
              <span class="links-of-author-item">
              <a href="http://aevit.xyz/" target="_blank">Aevit's Lab</a>
              </span>
            
              <span class="links-of-author-item">
              <a href="http://helkyle.com/" target="_blank">HelKyle's blog</a>
              </span>
            
              <span class="links-of-author-item">
              <a href="http://w3ctrain.com" target="_blank">W3cTrain</a>
              </span>
            
          
        </div>

      </section>

      
        <section class="post-toc-wrap sidebar-panel-active">
          <div class="post-toc-indicator-top post-toc-indicator"></div>
          <div class="post-toc">
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-5"><a class="nav-link" href="#Run_loop_剖析"><span class="nav-number">1.</span> <span class="nav-text">Run loop 剖析</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Run_loop_的模式"><span class="nav-number">2.</span> <span class="nav-text">Run loop 的模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#输入源"><span class="nav-number">3.</span> <span class="nav-text">输入源</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Port-Based_Sources"><span class="nav-number">3.1.</span> <span class="nav-text">Port-Based Sources</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#自定义输入源"><span class="nav-number">3.2.</span> <span class="nav-text">自定义输入源</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Cocoa_Perform_Selector_Source"><span class="nav-number">3.3.</span> <span class="nav-text">Cocoa Perform Selector Source</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#定时器源"><span class="nav-number">4.</span> <span class="nav-text">定时器源</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Run_Loop_Observer"><span class="nav-number">5.</span> <span class="nav-text">Run Loop Observer</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#事件的_Run_Loop_序列"><span class="nav-number">6.</span> <span class="nav-text">事件的 Run Loop 序列</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#什么时候能够使用_Run_Loop"><span class="nav-number">7.</span> <span class="nav-text">什么时候能够使用 Run Loop</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#使用_Run_Loop_对象"><span class="nav-number">8.</span> <span class="nav-text">使用 Run Loop 对象</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#获取一个_Run_Loop_对象"><span class="nav-number">8.1.</span> <span class="nav-text">获取一个 Run Loop 对象</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#配置_Run_Loop"><span class="nav-number">8.2.</span> <span class="nav-text">配置 Run Loop</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#开始一个_Run_Loop"><span class="nav-number">8.3.</span> <span class="nav-text">开始一个 Run Loop</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#退出_run_loop"><span class="nav-number">8.4.</span> <span class="nav-text">退出 run loop</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Run_Loop_对象跟线程安全"><span class="nav-number">8.5.</span> <span class="nav-text">Run Loop 对象跟线程安全</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#配置_Run_Loop_Source"><span class="nav-number">9.</span> <span class="nav-text">配置 Run Loop Source</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#定义自定义的输入源"><span class="nav-number">9.1.</span> <span class="nav-text">定义自定义的输入源</span></a></li></ol></li></ol></div>
            
          </div>
          <div class="post-toc-indicator-bottom post-toc-indicator"></div>
        </section>
      

      <div class="side-bar-foot-decorate">
        <div class="side-bar-man motion-element"></div>
        <div class="side-bar-star motion-element"></div>
      </div>
    </div>
  </aside>


    </main>

    <footer id="footer" class="footer">
        <div class="footer-inner">
            <div class="copyright" >
  
  &copy; &nbsp; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="icon-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Pandara</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT
  </a>
</div>



        </div>
    </footer>

    <div class="back-to-top"></div>
</div>

  
  
  
    
    

  

    <script type="text/javascript">
      var disqus_shortname = 'pandara';
      var disqus_identifier = '2015/12/17/Run Loops/';
      var disqus_title = 'Run Loops';
      var disqus_url = 'http://pandara.xyz/2015/12/17/Run Loops/';

      function run_disqus_script(disqus_script){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');
      
        run_disqus_script('embed.js');
      
    </script>
  


  
  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.4"></script>
  <script type="text/javascript" src="/js/fancybox-aevit.js"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.4"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.4" id="motion.global"></script>



  <script type="text/javascript" src="/js/search-toggle.js"></script>


  
<script type="text/javascript" src="/js/bootstrap.scrollspy.js?v=0.4.4" id="bootstrap.scrollspy.custom"></script>


<script type="text/javascript" id="sidebar.toc.highlight">
  $(document).ready(function () {
    var tocSelector = '.post-toc';
    var $tocSelector = $(tocSelector);
    var activeCurrentSelector = '.active-current';

    $tocSelector
      .on('activate.bs.scrollspy', function () {
        var $currentActiveElement = $(tocSelector + ' .active').last();

        removeCurrentActiveClass();
        $currentActiveElement.addClass('active-current');

        $tocSelector[0].scrollTop = $currentActiveElement.position().top;
      })
      .on('clear.bs.scrollspy', function () {
        removeCurrentActiveClass();
      });

    function removeCurrentActiveClass () {
      $(tocSelector + ' ' + activeCurrentSelector)
        .removeClass(activeCurrentSelector.substring(1));
    }

    function processTOC () {
      getTOCMaxHeight();
      toggleTOCOverflowIndicators();
    }

    function getTOCMaxHeight () {
      var height = $('.sidebar').height() -
                   $tocSelector.position().top -
                   $('.post-toc-indicator-bottom').height();

      $tocSelector.css('height', height);

      return height;
    }

    function toggleTOCOverflowIndicators () {
      tocOverflowIndicator(
        '.post-toc-indicator-top',
        $tocSelector.scrollTop() > 0 ? 'show' : 'hide'
      );

      tocOverflowIndicator(
        '.post-toc-indicator-bottom',
        $tocSelector.scrollTop() >= $tocSelector.find('ol').height() - $tocSelector.height() ? 'hide' : 'show'
      )
    }

    $(document).on('sidebar.motion.complete', function () {
      processTOC();
    });

    $('body').scrollspy({ target: tocSelector });
    $(window).on('resize', function () {
      if ( $('.sidebar').hasClass('sidebar-active') ) {
        processTOC();
      }
    });

    onScroll($tocSelector);

    function onScroll (element) {
      element.on('mousewheel DOMMouseScroll', function (event) {
          var oe = event.originalEvent;
          var delta = oe.wheelDelta || -oe.detail;
          var self = this;

          this.scrollTop += ( delta < 0 ? 1 : -1 ) * 30;
          event.preventDefault();

          toggleTOCOverflowIndicators();
      });
    }

    function tocOverflowIndicator (indicator, action) {
      $(indicator).velocity('stop').velocity({
        opacity: action === 'show' ? 0.4 : 0
      }, { duration: 100 });
    }

  });
</script>


  <script type="text/javascript" id="sidebar.nav">
    $(document).ready(function () {
      var html = $('html');

      $('.sidebar-nav li').on('click', function () {
        var item = $(this);
        var activeTabClassName = 'sidebar-nav-active';
        var activePanelClassName = 'sidebar-panel-active';
        if (item.hasClass(activeTabClassName)) {
          return;
        }

        var currentTarget = $('.' + activePanelClassName);
        var target = $('.' + item.data('target'));

        currentTarget.velocity('transition.slideUpOut', 200, function () {
          target
            .velocity('stop')
            .velocity('transition.slideDownIn', 200)
            .addClass(activePanelClassName);
        });

        item.siblings().removeClass(activeTabClassName);
        item.addClass(activeTabClassName);
      });

      $('.post-toc a').on('click', function (e) {
        e.preventDefault();
        var offset = $(escapeSelector(this.getAttribute('href'))).offset().top;
        html.velocity('stop').velocity('scroll', {
          offset: offset  + 'px',
          mobileHA: false
        });
      });

      // Expand sidebar on post detail page by default, when post has a toc.
      var $tocContent = $('.post-toc-content');
      if (isDesktop() && CONFIG.sidebar === 'post') {
        if ($tocContent.length > 0 && $tocContent.html().trim().length > 0) {
          displaySidebar();
        }
      }
    });
  </script>




<script type="text/javascript">
    $(document).ready(function () {
        if (CONFIG.sidebar === 'always') {
            displaySidebar();
        }
    });
</script>








<!-- lazyload -->
<script type="text/javascript" src="/js/lazyload.js"></script>
<script type="text/javascript">
    jQuery(function () {
        jQuery("#posts img").lazyload({
            placeholder: "/images/loading.gif",
            effect: "fadeIn"
        });
    });
</script>
</body>
</html>